---
layout: post
title: Spring 数据类型转换：PropertyEditor
date: 2023-08-27
category: Spring
tags: [Spring PropertyEditor]
excerpt: 
---

### 目录

+ [Java 类型转换](#T-1)
+ [Spring 类型转换](#T-2)
+ [PropertyEditor 类型转换体系](#T-3)
    - [PropertyEditor](#T-3.1)
    - [PropertyEditorSupport](#T-3.2)
    - [PropertyEditor 的基本使用](#T-3.3)
    - [自定义 PropertyEditor](#T-3.4)
    - [PropertyEditor 注册/管理](#T-3.5)
        + [PropertyEditorRegistry](#T-3.5.1)
        + [PropertyEditorRegistrySupport](#T-3.5.2)
            - [PropertyEditor 的注册过程](#T-3.5.2.1)
            - [PropertyEditor 的查找过程](#T-3.5.2.2)
            - [默认 PropertyEditor 转换器](#T-3.5.2.3)
        + [PropertyEditorRegistrar](#T-3.5.3)
    - [TypeConverter](#T-3.6)
    - [BeanWrapper](#T-3.7)
        + [BeanWrapper 基本使用](#T-3.7.1)
        + [BeanWrapper 注册/查找类型转换器](#T-3.7.2)
            - [初始化 BeanWrapper](#T-3.7.2.1)
            - [为 BeanWrapper 注册自定义转换器](#T-3.7.2.2)
        + [BeanWrapper 属性管理](#T-3.7.3)
            - [Bean 属性类型转换](#T-3.7.3.1)
            - [Bean 属性注入/访问](#T-3.7.3.2)
    - [基于 PropertyEditor 类型转换的缺陷](#T-3.8)
+ [Spring 3.0 类型转换接口 Converter](#T-4)
+ [Spring 3.0 转换服务接口 ConversionService](#T-5)
+ [Spring 3.0 类型转换整合格式化 Formatter](#T-6)

## Java 类型转换 {#T-1}

Java 是个多类型且强类型语言，类型转换这个概念对它来说并不陌生。比如：

+ 自动类型转换（隐式）：小类型 -> 大类型。eg：`int a = 10; double b = a;`

+ 强制类型转换（显式）：大类型 -> 小类型。eg：`double a = 3.14; int b = (int) a;` 

    - 注意：强转有可能产生精度丢失

+ 调用 API 转换：常见的是字符串和其它类型的互转。

    - 例如：`parseInt(String); parseBoolean(String); LocalDate.parse(String)`

在企业级开发环境中，会遇到更为复杂的数据转换场景，譬如说：

1. 输入一个规格字符串（如：`1, 2, 3, 4, 5`），转换为一个数组。

2. 输入一个 JSON 串（如：`{"name":"zhangsan", "age":28}`），转换为一个 `Person` 对象。

3. 输入一个 URL 串（如：`C:/test.txt、classpath:test.txt`），转换为一个 `org.springframework.core.io.Resource` 对象。

虽说数据输入绝大部分都会是字符串（如 `HTTP` 请求信息、`XML` 配置信息），但数据结构千差万别，转换过程必然会涉及到大量的数据类型、结构转换的逻辑。倘若手动编码做转换处理会非常麻烦，如果使用 Spring 则可以实现自动化类型转换。

## Spring 类型转换 {#T-2}

Spring 2.x 在版本升级变更之后，类型转换体系也随之发生了很大的变化，从 3.0 前的 PropertyEditor 体系转变为 3.0 后的 Converter 和 Formatter 转换体系。本文会先从早期的 PropertyEditor 开始分析，然后再分析 3.0 后的类型转换体系；分析 ProperyEditor 的实现有助于我们对 Spring 内部类型转换机制的理解，通过对比不同类型转换系统的差异，理解版本升级所带来的意义与好处。

![spring-data-converter-structure](https://s1.imagehub.cc/images/2023/09/02/spring-data-converter-structure.png)

## PropertyEditor 类型转换体系 {#T-3}

### PropertyEditor {#T-3.1}

早期的 Spirng 类型转换是基于 Java Beans 接口 `java.beans.PropertyEditor` 来实现的，其实现类全部继承至 `PropertyEditorSupport`。通过 `java.beans.PropertyEditor` 其包名我们就可以看出，其本身并非 Spring 中定义的接口，它其实是 `Java Bean` 规范中所定义的一个接口，其设计初衷在于是用于完成 GUI 中的输入与对象属性之间的转换操作；Spring 只是借用了 `PropertyEditor` 这个接口的定义与功能，来完成字符串与对象属性之间的转换。

```java
public interface PropertyEditor {
    
    /**
     * Set (or change) the object that is to be edited.  Primitive types such
     * as "int" must be wrapped as the corresponding object type such as
     * "java.lang.Integer".
     *
     * @param value The new target object to be edited.  Note that this
     *     object should not be modified by the PropertyEditor, rather
     *     the PropertyEditor should create a new object to hold any
     *     modified value.
     */
    void setValue(Object value);

    /**
     * Gets the property value.
     *
     * @return The value of the property.  Primitive types such as "int" will
     * be wrapped as the corresponding object type such as "java.lang.Integer".
     */

    Object getValue();

    /**
     * Gets the property value as text.
     *
     * @return The property value as a human editable string.
     * Returns null if the value can't be expressed as an editable string.
     * If a non-null value is returned, then the PropertyEditor should
     * be prepared to parse that string back in setAsText().
     */
    String getAsText();

    /**
     * Set the property value by parsing a given String.  May raise
     * java.lang.IllegalArgumentException if either the String is
     * badly formatted or if this kind of property can't be expressed
     * as text.
     * @param text  The string to be parsed.
     */
    void setAsText(String text) throws java.lang.IllegalArgumentException;

    ...
}
```

在 Spring 3.0 之前，在 Spring 整个体系中，所有完成字符串与其他数据类型转换操作都是由 `ProperyEditor` 接口来完成的。Spring 通过 `PropertyEditor` 作为其数据类型转换的基础架构，同时自己还定义了许多默认的 `ProrpertyEditor` 的实现，这些实现类都位于 `spring-beans` 模块中的 `org.springframework.beans.propertyeditors` 包中。 

![spring-propertyeditors-package](https://s1.imagehub.cc/images/2023/09/02/spring-propertyeditors-package.png)

这些内置的 `PropertyEditor` 会有**部分**在默认情况下就已经被注册到 IOC 容器中，而有些 `PropertyEditor` 在默认情况下并没有自动加入，需要用户手动注册，后面我们通过源码可以看到 Spring 默认所注册了哪些 `PropertyEditor`。

### PropertyEditorSupport {#T-3.2}

由于 `PropertyEditor` 是一个类型转换的接口，其里面定义了很多与实际应用无关的方法。如果要自定义属性转换器通常只需要继承 `java.beans.PropertyEditorSupport` 这个类，并且重写 `setAsText(String text)` 方法，在类型转换的时候如果值是字符串会调用 `setAsText` 来赋值，其它情况下会调用 `setValue` 来赋值，然后再调用 `getValue` 获取转换后的属性值。相当于将 `PropertyEditor` 作为一个加工坊，传进一个原始值返回预期类型的值。Spring 内置的默认 `PropertyEditor` 也都是通过继承 `PropertyEditorSupport` 来完成类型转换的。

### PropertyEditor 的基本使用 {#T-3.3}

给出两个非常简单的类，我们希望完成的是输入字符串 `5, 10` 将其自动分割并转换成 `point` 对象的 `x` 和 `y` 属性。  

```java
public class Point {

    int x, y;

    public int getX() {
        return x;
    }

    public void setX(int x) {
        this.x = x;
    }

    public int getY() {
        return y;
    }

    public void setY(int y) {
        this.y = y;
    }

    @Override
    public String toString() {
        return new StringJoiner(", ", Point.class.getSimpleName() + "[", "]")
                .add("x=" + x)
                .add("y=" + y)
                .toString();
    }
}
```

定义 Circle 类，这里使用 `@Value` 注解来模拟字符串属性的注入和解析。

```java
public class Circle {

    @Value("5, 10")
    private Point point;

    public Point getPoint() {
        return point;
    }

    public void setPoint(Point point) {
        this.point = point;
    }

    @Override
    public String toString() {
        return new StringJoiner(", ", Circle.class.getSimpleName() + "[", "]")
                .add("point=" + point)
                .toString();
    }
}
```

### 自定义 PropertyEditor {#T-3.4}

```java
public class PointEditor extends PropertyEditorSupport {

    @Override
    public void setAsText(String text) throws IllegalArgumentException {
        String[] splits = text.split(",");
        Point point = new Point();
        point.setX(Integer.parseInt(splits[0].trim()));
        point.setY(Integer.parseInt(splits[1].trim()));
        // 将装换后的结果设置到 Editor 的 value 属性，
        // 因为外部会通过 getValue() 获取到转换的结果。
        setValue(point);
    }
}
```

在完成 `ProperyEditor` 编写后，只需将其注册到 IOC 容器中即可自动完成 `String` 到 `Point` 之间的转换。

```java
public class PointEditorRegistrar implements PropertyEditorRegistrar {

    @Override
    public void registerCustomEditors(PropertyEditorRegistry registry) {
        registry.registerCustomEditor(Point.class, new PointEditor());
    }
}
```

```java
@Configuration
public class PropertyEditorConfig {

    @Bean
    CustomEditorConfigurer customEditorConfigurer(){
        CustomEditorConfigurer configurer = new CustomEditorConfigurer();
        PointEditorRegistrar registrar = new PointEditorRegistrar();
        // 使用 PropertyEditorRegistrar 完成注册 [文档推荐方式]
        configurer.setPropertyEditorRegistrars(new PropertyEditorRegistrar[]{registrar});
        return configurer;
    }

    @Bean
    Circle circle(){
        return new Circle();
    }

}
```

这里使用 `BeanFactoryPostProcessor` 的实现类 `CustomEditorConfigurer`，该类会在完成 `BeanFactory` 初始化后，通过 `postProcessBeanFactory` 方法向容器中注册自定义的 PropertyEditor。需要注意的是 **PropertyEditor 是有状态的，即非线程安全的**，因此每次尝试属性编辑都必须同步这些实例或者创建一个新的实例；如果需要控制 PropertyEditor 的实例化过程，请使用 `PropertyEditorRegistrar` 来注册它们而不是直接使用 `customEditors` 属性来注册 ，这也是源码注释推荐的一种方式。

```java
// 详细使用说明参见该类的源码注释
public class CustomEditorConfigurer implements BeanFactoryPostProcessor, Ordered {

    protected final Log logger = LogFactory.getLog(getClass());

    private int order = Ordered.LOWEST_PRECEDENCE;  // default: same as non-Ordered

    @Nullable
    private PropertyEditorRegistrar[] propertyEditorRegistrars;

    @Nullable
    private Map<Class<?>, Class<? extends PropertyEditor>> customEditors;


    public void setOrder(int order) {
        this.order = order;
    }

    @Override
    public int getOrder() {
        return this.order;
    }

    /**
     * Specify the {@link PropertyEditorRegistrar PropertyEditorRegistrars}
     * to apply to beans defined within the current application context.
     * This allows for sharing {@code PropertyEditorRegistrars} with
     * {@link org.springframework.validation.DataBinder DataBinders}, etc.
     * Furthermore, it avoids the need for synchronization on custom editors:
     * A {@code PropertyEditorRegistrar} will always create fresh editor
     * instances for each bean creation attempt.
     * @see ConfigurableListableBeanFactory#addPropertyEditorRegistrar
     */
    public void setPropertyEditorRegistrars(PropertyEditorRegistrar[] propertyEditorRegistrars) {
        this.propertyEditorRegistrars = propertyEditorRegistrars;
    }

    /**
     * Specify the custom editors to register via a {@link Map}, using the
     * class name of the required type as the key and the class name of the
     * associated {@link PropertyEditor} as value.
     * @see ConfigurableListableBeanFactory#registerCustomEditor
     */
    public void setCustomEditors(Map<Class<?>, Class<? extends PropertyEditor>> customEditors) {
        this.customEditors = customEditors;
    }

    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
        if (this.propertyEditorRegistrars != null) {
            for (PropertyEditorRegistrar propertyEditorRegistrar : this.propertyEditorRegistrars) {
                beanFactory.addPropertyEditorRegistrar(propertyEditorRegistrar);
            }
        }
        if (this.customEditors != null) {
            this.customEditors.forEach(beanFactory::registerCustomEditor);
        }
    }

}

```

编写测试类验证：


```java
public class PropertyEditorTest {

    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(PropertyEditorConfig.class);
        Object circle = context.getBean("circle");
        System.out.println(circle);
    }
}
```

控制台输出：

```consoe
Circle[point=Point[x=5, y=10]]
```

除了通过 `CustomEditorConfigurer` 来完成自定义 `PropertyEditor` 的注入，Spring 也支持另外一种基于 `Java Bean` 规范的**自动查找机制**。这种方式要求自定义的 PropertyEditor 必须与对应的类型在同一个包下，并且其名字必须为 `xxxEditor`，这样才能实现自动查询的功能。下面进行简单验证，由于本例中的 Bean 命名符合此规范，所以只需将配置类中的 `customEditorConfigurer` 的 `@Bean` 注解去掉，启动测试类控制台输出：`Circle[point=Point[x=5, y=10]]`，与使用 `CustomEditorConfigurer` 输出结果一致；若将 `PointEditor` 改为其它名称则会抛出异常：

```console
Caused by: java.lang.IllegalStateException: Cannot convert value of type 'java.lang.String' to required type 'org.spring.demo.conversion.propertyeditor.Point': no matching editors or conversion strategy found
    at org.springframework.beans.TypeConverterDelegate.convertIfNecessary(TypeConverterDelegate.java:299)
    at org.springframework.beans.TypeConverterDelegate.convertIfNecessary(TypeConverterDelegate.java:117)
    at org.springframework.beans.TypeConverterSupport.doConvert(TypeConverterSupport.java:70)
    ... 18 more

```

通过上面的运行结果我们可以看到，我们自己所定义的 `ProeprtyEditor` 确实已经被 Spring 容器所管理，并且成功地完成了类型转换。Spring 在背后具体做了什么？对于我们而言却一无所知，下面从源码的角度仔细分析一下 Spring 如何对 `PropertyEditor` 进行管理的，如何将字符串转换成我们期望的类型。

### PropertyEditor 注册/管理 {#T-3.5}

首先，我们应该所思考的问题：Spring 中的内置的 `PropertEditor` 与自定义的 `ProeprtyEditor` 是由**谁**来管理的? 是 `BeanFactory` 还是 `ApplicationContext`? 两者都不算非常准确，真正完成管理的其实是 `PropertyEditorRegistry`，下面我们对这个接口做一个比较细致的分析。

#### PropertyEditorRegistry {#T-3.5.1}

接口 `org.springframework.beans.PropertyEditorRegistry` 提供了对 `PropertyEditor` **注册**、**查找** 等管理功能，首先看看接口描述:

```java
/**
 * Encapsulates methods for registering JavaBeans PropertyEditors. 
 * This is the central interface that a PropertyEditorRegistrar operates on.
 * Extended by BeanWrapper; implemented by BeanWrapperImpl and org.springframework.validation.DataBinder.
 * 
 * 封装用于注册JavaBeans PropertyEditors的方法，这是PropertyEditorRegistrar操作的中心接口。
 * 由BeanWrapper扩展，由BeanWrapperImpl和org.springframework.validation.DataBinder实现。
 */
public interface PropertyEditorRegistry {

    /**
     * Register the given custom property editor for all properties of the given type.
     * 
     * Note: 根据属性类型注册其对应的 PropertyEditor
     * 
     * @param requiredType the type of the property
     * @param propertyEditor the editor to register
     */
    void registerCustomEditor(Class<?> requiredType, PropertyEditor propertyEditor);

    /**
     * Register the given custom property editor for the given type and
     * property, or for all properties of the given type.
     * 
     * Note：根据属性类型以及属性路径来注册其对应的 PropertyEditor，相当于为某个属性自定义一个专属转换器
     * 
     * If the property path denotes an array or Collection property,
     * the editor will get applied either to the array/Collection itself
     * (the {@link PropertyEditor} has to create an array or Collection value) or
     * to each element (the {@code PropertyEditor} has to create the element type),
     * depending on the specified required type.
     * Note: Only one single registered custom editor per property path
     * is supported. In the case of a Collection/array, do not register an editor
     * for both the Collection/array and each element on the same property.
     * For example, if you wanted to register an editor for "items[n].quantity"
     * (for all values n), you would use "items.quantity" as the value of the
     * 'propertyPath' argument to this method.
     * @param requiredType the type of the property. This may be {@code null}
     * if a property is given but should be specified in any case, in particular in
     * case of a Collection - making clear whether the editor is supposed to apply
     * to the entire Collection itself or to each of its entries. So as a general rule:
     * Do not specify {@code null} here in case of a Collection/array!
     * @param propertyPath the path of the property (name or nested path), or
     * {@code null} if registering an editor for all properties of the given type
     * @param propertyEditor editor to register
     */
    void registerCustomEditor(@Nullable Class<?> requiredType, @Nullable String propertyPath, PropertyEditor propertyEditor);

    /**
     * Find a custom property editor for the given type and property.
     * 
     * Note：根据指定类型以及属性路径，查询其对应的 ProeprtyEditor，属性路径可以为 Null
     * 
     * @param requiredType the type of the property (can be {@code null} if a property
     * is given but should be specified in any case for consistency checking)
     * @param propertyPath the path of the property (name or nested path), or
     * {@code null} if looking for an editor for all properties of the given type
     * @return the registered editor, or {@code null} if none
     */
    @Nullable
    PropertyEditor findCustomEditor(@Nullable Class<?> requiredType, @Nullable String propertyPath);

}

```

#### PropertyEditorRegistrySupport {#T-3.5.2}

`PropertyEditorRegistry` 只是定义了对 `PropertyEditor` 注册和查找的方法，其具体的核心实现类是 `org.springframework.beans.PropertyEditorRegistrySupport`，实际对 `PropertyEditor` 管理的方法全部在该类中实现。

```java
 // 该类的全部属性定义如下
 public class PropertyEditorRegistrySupport implements PropertyEditorRegistry {

    // ConversionService转换器
    private ConversionService conversionService;

    // 是否启用默认转换器
    private boolean defaultEditorsActive = false;

    // register config value editors if true.
    // {@see PropertyEditorRegistrySupport#createDefaultEditors}
    private boolean configValueEditorsActive = false;

    // 默认内建的类型转换器
    private Map<Class<?>, PropertyEditor> defaultEditors;

    // 覆盖默认的类型转换器：作用参见 getDefaultEditor 方法 
    // 一些注册器在注册转换器时会进行覆盖：{@see org.springframework.beans.support.ResourceEditorRegistrar}
    private Map<Class<?>, PropertyEditor> overriddenDefaultEditors;

    // 用户自定义的类型转换器
    private Map<Class<?>, PropertyEditor> customEditors;

    // //绑定属性名称的类型转换器
    private Map<String, CustomEditorHolder> customEditorsForPath;

    // 用于存储属性类型对应的父类型的类型转换器
    private Map<Class<?>, PropertyEditor> customEditorCache;
}
```

`PropertyEditorRegistrySupport` 实现了 `PropertyEditorRegistry` 接口，该类默认实现了类型转换器的注册和查找功能；`PropertyEditorRegistrySupport` 声明了多个 `Map` 用于存储不同来源的转换器。由于 `PropertyEditor` 是存储在 `Map` 中的，目标类型作为 `key`，所以每一个类型只能注册一个 `PropertyEditor`，后注册的会覆盖先注册的；同时该类还声明一个 `conversionService` 属性，这是 Spring 3.0 新增的另一种类型转换接口 `ConversionService`，它通过调用相应的 `Converter` 进行类型转换。因此 `PropertyEditorRegistrySupport`不仅可以注册 `PropertyEditor` 还可以注册 `ConversionService`，相当于是一个杂烩饭大王，可以说是 Spring 管理各种类型转换器的一个仓库。

##### PropertyEditor 的注册过程 {#T-3.5.2.1}

```java
// org.springframework.beans.PropertyEditorRegistrySupport#registerCustomEditor
public void registerCustomEditor(@Nullable Class<?> requiredType, @Nullable String propertyPath, PropertyEditor propertyEditor) {
    if (requiredType == null && propertyPath == null) {
        throw new IllegalArgumentException("Either requiredType or propertyPath is required");
    }
    // 给属性名注册特定的类型转换器
    if (propertyPath != null) {
        if (this.customEditorsForPath == null) {
            this.customEditorsForPath = new LinkedHashMap<>(16);
        }
        // 特定转换器保存在 customEditorsForPath
        this.customEditorsForPath.put(propertyPath, new CustomEditorHolder(propertyEditor, requiredType));
    }
    // 注册自定义类型转换器
    else {
        if (this.customEditors == null) {
            this.customEditors = new LinkedHashMap<>(16);
        }
        // 自定义转换器保存在 customEditors
        this.customEditors.put(requiredType, propertyEditor);
        this.customEditorCache = null;
    }
}
```

上文提到 `PropertyEditor` 保存在一个 `Map` 中，`key` 是目标类型，那么这个参数 `propertyPath` 用途是什么? 这是为了给属性名指定专属的类型转换器。因为每个目标类型只能对应一个 `PropertyEditor`，但是有时某个属性的类型转换比较特殊，这时就可以给这个属性名单独注册一个类型转换器，不会覆盖该属性类型对应的转换器，如果覆盖会影响其它相同类型的属性转换。

##### PropertyEditor 的查找过程 {#T-3.5.2.2}

```java
// org.springframework.beans.PropertyEditorRegistrySupport#findCustomEditor
public PropertyEditor findCustomEditor(@Nullable Class<?> requiredType, @Nullable String propertyPath) {
    Class<?> requiredTypeToUse = requiredType;
    if (propertyPath != null) {
        if (this.customEditorsForPath != null) {
            // Check property-specific editor first.
            PropertyEditor editor = getCustomEditor(propertyPath, requiredType);
            if (editor == null) {
                List<String> strippedPaths = new ArrayList<>();
                // 解析字段名，如 a.b[0]
                addStrippedPropertyPaths(strippedPaths, "", propertyPath);
                for (Iterator<String> it = strippedPaths.iterator(); it.hasNext() && editor == null;) {
                    String strippedPath = it.next();
                    editor = getCustomEditor(strippedPath, requiredType);
                }
            }
            if (editor != null) {
                return editor;
            }
        }
        if (requiredType == null) {
            // 获取给定属性路径的属性类型(由子类实现: BeanWrapperImpl)
            requiredTypeToUse = getPropertyType(propertyPath);
        }
    }
    // No property-specific editor -> check type-specific editor.
    return getCustomEditor(requiredTypeToUse);
}
```

1. 查找时首先根据属性名从 `customEditorsForPath` 查找特定的类型转换器；

2. 如果 `propertyPath`为空或没有找到特殊类型转换器，则再根据属性类型查找自定义类型转换器；

3. 如果没有对应的目标类型转换器，则查找该类型的父类对应的类型转换器并保存在缓存。

```java
// org.springframework.beans.PropertyEditorRegistrySupport#getCustomEditor
private PropertyEditor getCustomEditor(@Nullable Class<?> requiredType) {
    if (requiredType == null || this.customEditors == null) {
        return null;
    }
    // Check directly registered editor for type.
    PropertyEditor editor = this.customEditors.get(requiredType);
    if (editor == null) {
        // Check cached editor for type, registered for superclass or interface.
        if (this.customEditorCache != null) {
            editor = this.customEditorCache.get(requiredType);
        }
        if (editor == null) {
            // Find editor for superclass or interface.
            // 遍历已有的类型转换器，如果类型是 requiredType 的父类则使用该类型转换器
            for (Iterator<Class<?>> it = this.customEditors.keySet().iterator(); it.hasNext() && editor == null;) {
                Class<?> key = it.next();
                if (key.isAssignableFrom(requiredType)) {
                    editor = this.customEditors.get(key);
                    // Cache editor for search type, to avoid the overhead
                    // of repeated assignable-from checks.
                    if (this.customEditorCache == null) {
                        this.customEditorCache = new HashMap<>();
                    }
                    this.customEditorCache.put(requiredType, editor);
                }
            }
        }
    }
    return editor;
}
```

##### 默认 PropertyEditor 转换器 {#T-3.5.2.3}

前文提到 Spring 容器会内置一些默认的 `PropertyEditor`，当用户没有添加自定义转换器时可以进行一些基本的类型转换，达到开箱即用的效果。实际上这些内置的类型转换器在真正获取时才会进行创建和注册，具体在 `PropertyEditorRegistrySupport#getDefaultEditor` 方法中通过 `createDefaultEditors()` 进行注册。 

```java
// org.springframework.beans.PropertyEditorRegistrySupport#getDefaultEditor
public PropertyEditor getDefaultEditor(Class<?> requiredType) {
    // 该属性为 true 时才会注册默认转换器
    if (!this.defaultEditorsActive) {
        return null;
    }
    // 从覆盖的默认类型转换器中查找
    // 一些注册器在注册转换器时会进行覆盖：{@see org.springframework.beans.support.ResourceEditorRegistrar}
    if (this.overriddenDefaultEditors != null) {
        PropertyEditor editor = this.overriddenDefaultEditors.get(requiredType);
        if (editor != null) {
            return editor;
        }
    }
    // 初始化默认类型转换器
    if (this.defaultEditors == null) {
        createDefaultEditors();
    }
    // 键值对查找
    return this.defaultEditors.get(requiredType);
}
```

**初始化默认类型转换器**

```java
// org.springframework.beans.PropertyEditorRegistrySupport#createDefaultEditors
private void createDefaultEditors() {
    this.defaultEditors = new HashMap<>(64);

    // Simple editors, without parameterization capabilities.
    // The JDK does not contain a default editor for any of these target types.
    this.defaultEditors.put(Charset.class, new CharsetEditor());
    this.defaultEditors.put(Class.class, new ClassEditor());
    this.defaultEditors.put(Class[].class, new ClassArrayEditor());
    this.defaultEditors.put(Currency.class, new CurrencyEditor());
    this.defaultEditors.put(File.class, new FileEditor());
    this.defaultEditors.put(InputStream.class, new InputStreamEditor());
    this.defaultEditors.put(InputSource.class, new InputSourceEditor());
    this.defaultEditors.put(Locale.class, new LocaleEditor());
    this.defaultEditors.put(Path.class, new PathEditor());
    this.defaultEditors.put(Pattern.class, new PatternEditor());
    this.defaultEditors.put(Properties.class, new PropertiesEditor());
    this.defaultEditors.put(Reader.class, new ReaderEditor());
    this.defaultEditors.put(Resource[].class, new ResourceArrayPropertyEditor());
    this.defaultEditors.put(TimeZone.class, new TimeZoneEditor());
    this.defaultEditors.put(URI.class, new URIEditor());
    this.defaultEditors.put(URL.class, new URLEditor());
    this.defaultEditors.put(UUID.class, new UUIDEditor());
    this.defaultEditors.put(ZoneId.class, new ZoneIdEditor());

    // Default instances of collection editors.
    // Can be overridden by registering custom instances of those as custom editors.
    this.defaultEditors.put(Collection.class, new CustomCollectionEditor(Collection.class));
    this.defaultEditors.put(Set.class, new CustomCollectionEditor(Set.class));
    this.defaultEditors.put(SortedSet.class, new CustomCollectionEditor(SortedSet.class));
    this.defaultEditors.put(List.class, new CustomCollectionEditor(List.class));
    this.defaultEditors.put(SortedMap.class, new CustomMapEditor(SortedMap.class));

    // Default editors for primitive arrays.
    this.defaultEditors.put(byte[].class, new ByteArrayPropertyEditor());
    this.defaultEditors.put(char[].class, new CharArrayPropertyEditor());

    // The JDK does not contain a default editor for char!
    this.defaultEditors.put(char.class, new CharacterEditor(false));
    this.defaultEditors.put(Character.class, new CharacterEditor(true));

    // Spring's CustomBooleanEditor accepts more flag values than the JDK's default editor.
    this.defaultEditors.put(boolean.class, new CustomBooleanEditor(false));
    this.defaultEditors.put(Boolean.class, new CustomBooleanEditor(true));

    // The JDK does not contain default editors for number wrapper types!
    // Override JDK primitive number editors with our own CustomNumberEditor.
    this.defaultEditors.put(byte.class, new CustomNumberEditor(Byte.class, false));
    this.defaultEditors.put(Byte.class, new CustomNumberEditor(Byte.class, true));
    this.defaultEditors.put(short.class, new CustomNumberEditor(Short.class, false));
    this.defaultEditors.put(Short.class, new CustomNumberEditor(Short.class, true));
    this.defaultEditors.put(int.class, new CustomNumberEditor(Integer.class, false));
    this.defaultEditors.put(Integer.class, new CustomNumberEditor(Integer.class, true));
    this.defaultEditors.put(long.class, new CustomNumberEditor(Long.class, false));
    this.defaultEditors.put(Long.class, new CustomNumberEditor(Long.class, true));
    this.defaultEditors.put(float.class, new CustomNumberEditor(Float.class, false));
    this.defaultEditors.put(Float.class, new CustomNumberEditor(Float.class, true));
    this.defaultEditors.put(double.class, new CustomNumberEditor(Double.class, false));
    this.defaultEditors.put(Double.class, new CustomNumberEditor(Double.class, true));
    this.defaultEditors.put(BigDecimal.class, new CustomNumberEditor(BigDecimal.class, true));
    this.defaultEditors.put(BigInteger.class, new CustomNumberEditor(BigInteger.class, true));

    // Only register config value editors if explicitly requested.
    if (this.configValueEditorsActive) {
        StringArrayPropertyEditor sae = new StringArrayPropertyEditor();
        this.defaultEditors.put(String[].class, sae);
        this.defaultEditors.put(short[].class, sae);
        this.defaultEditors.put(int[].class, sae);
        this.defaultEditors.put(long[].class, sae);
    }
}
```

#### PropertyEditorRegistrar {#T-3.5.3}

```java
/**
 * nterface for strategies that register custom property editors with a property editor registry.
 * This is particularly useful when you need to use the same set of property editors in several different situations: 
 * write a corresponding registrar and reuse that in each case.
 */
public interface PropertyEditorRegistrar {

    /**
     * Register custom {@link java.beans.PropertyEditor PropertyEditors} with
     * the given {@code PropertyEditorRegistry}.
     * <p>The passed-in registry will usually be a {@link BeanWrapper} or a
     * {@link org.springframework.validation.DataBinder DataBinder}.
     * <p>It is expected that implementations will create brand new
     * {@code PropertyEditors} instances for each invocation of this
     * method (since {@code PropertyEditors} are not threadsafe).
     * @param registry the {@code PropertyEditorRegistry} to register the
     * custom {@code PropertyEditors} with
     */
    void registerCustomEditors(PropertyEditorRegistry registry);
}
```

从接口描述中可以看到 `PropertyEditorRegistrar` 的作用是将用户自定义的 `PropertyEditor` 注册到 `PropertyEditorRegistry` 中。注册方法 `registerCustomEditor` 的参数 `PropertyEditorRegistry` 用于将用户自定义的 `ProepertyEditor` 注册到 `PropertyEditorRegistry` 被其管理。

`PropertyEditorRegistrar` 可将一组相同的 `PropertyEditor` 应用在多个地方，比如将一组相同的 `PropertyEditor` 应用在 IOC 容器，同时又应用在 Spring MVC 的 `DataBinder`，此时就可以先定义一个 `PropertyEditorRegistrar` 的实现类，来完成通用的 `ProepertyEditor` 注册操作，然后将 `PropertyEditorRegistrar` 作为一个 `ProeprtyEditor` 的集合设置到不同的地方，此时就可以做到代码复用。

_PS：相同的 PropertyEditor 需要在多处进行注册的原因是因为如果在 IOC 容器中通过 CustomEditorConfigurer 添加了自定义的 PropertyEditor ，这样并不会对 SpringMVC 中所使用的 DataBinder 生效，因此需要再次进行注册，在 CustomEditorConfigurer 源码注释中可清楚地看到这点说明。_

### TypeConverter {#T-3.6}

`TypeConverter` 是定义类型转换方法的底层接口，它在 Spring 2.x 就已经存在。在增加 `ConversionService` 之前，它的类型转换动作均委托给已注册的 `PropertyEditor` 来完成。但自 3.0 之后，这个转换动作可能交给 `PropertyEditor` 来执行，也可能交给 `ConversionService` 来处理。

```java
/**
 * Interface that defines type conversion methods. Typically (but not necessarily) implemented in conjunction with the 
 * PropertyEditorRegistry interface.
 * Note: Since TypeConverter implementations are typically based on PropertyEditors which aren't thread-safe, TypeConverters 
 * themselves are not to be considered as thread-safe either.(非线程安全)
 */
public interface TypeConverter {

    /**
     * Convert the value to the required type (if necessary from a String).
     * Conversions from String to any type will typically use the {@code setAsText}
     * method of the PropertyEditor class, or a Spring Converter in a ConversionService.
     * @param value the value to convert
     * @param requiredType the type we must convert to
     * (or {@code null} if not known, for example in case of a collection element)
     * @return the new value, possibly the result of type conversion
     */
    @Nullable
    <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType) throws TypeMismatchException;

    /**
     * Convert the value to the required type (if necessary from a String).
     * Conversions from String to any type will typically use the {@code setAsText}
     * method of the PropertyEditor class, or a Spring Converter in a ConversionService.
     * @param value the value to convert
     * @param requiredType the type we must convert to
     * (or {@code null} if not known, for example in case of a collection element)
     * @param methodParam the method parameter that is the target of the conversion
     * (for analysis of generic types; may be {@code null})
     * @return the new value, possibly the result of type conversion
     */
    @Nullable
    <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,
            @Nullable MethodParameter methodParam) throws TypeMismatchException;

    /**
     * Convert the value to the required type (if necessary from a String).
     * Conversions from String to any type will typically use the {@code setAsText}
     * method of the PropertyEditor class, or a Spring Converter in a ConversionService.
     * @param value the value to convert
     * @param requiredType the type we must convert to
     * (or {@code null} if not known, for example in case of a collection element)
     * @param field the reflective field that is the target of the conversion
     * (for analysis of generic types; may be {@code null})
     * @return the new value, possibly the result of type conversion
     */
    @Nullable
    <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType, @Nullable Field field)
            throws TypeMismatchException;

    /**
     * Convert the value to the required type (if necessary from a String).
     * Conversions from String to any type will typically use the {@code setAsText}
     * method of the PropertyEditor class, or a Spring Converter in a ConversionService.
     * @param value the value to convert
     * @param requiredType the type we must convert to
     * (or {@code null} if not known, for example in case of a collection element)
     * @param typeDescriptor the type descriptor to use (may be {@code null}))
     * @return the new value, possibly the result of type conversion
     * @since 5.1.4
     */
    @Nullable
    default <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,
            @Nullable TypeDescriptor typeDescriptor) throws TypeMismatchException {

        throw new UnsupportedOperationException("TypeDescriptor resolution not supported");
    }

}
```

`TypeConverter` 是 Spring 内部执行类型转换的**入口**，Spring 把执行类型转换的方法注册在 `TypeConverter`，然后将类型转换任务交给其具体的实现类来完成，最终会委托 `PropertyEditor` 或者 `ConversionService` 完成类型转换。它的主要实现有：

+ `TypeConverterSupport`：继承自 `PropertyEditorRegistrySupport` 并为子类 `BeanWrapperImpl` 提供功能支撑，主要作用如下：

    1、提供对`默认编辑器`（支持JDK内置类型转换 如：Charset、Class、Class\[\]、Properties、Collection）和`自定义编辑器`的管理（PropertyEditorRegistry#registerCustomEditor）

    2、提供 getter/setter 方法，注入 `ConversionService`（可选依赖）

+ `DataBinder`：因为数据绑定**强依赖于**类型转换，因此数据绑定涉及到的属性访问操作将会依赖于此组件，不管是直接访问属性的 `DirectFieldAccessor` 还是功能更强大的 `BeanWrapperImpl` 均是如此。

### BeanWrapper {#T-3.7}

BeanWrapper 是 Spring 中一个比较底层的接口，一般不会使用到这个接口，其主要由 Spring 内部来使用。Spring 实例化 Bean 过程中对属性值的转换就是使用 BeanWrappper 的实现类 BeanWrapperImpl 来完成。`BeanWrapper` 除了提供了标准的 JavaBean 的访问方式以外，同时还继承了三个顶级接口 `PropertyAccessor`、`PropertyEditorRegistry`、`TypeConverter`，提供了对象属性访问、类型转换器的注册和查找、类型转换功能。

![spring-type-converter](https://s1.imagehub.cc/images/2023/09/02/spring-type-converter-class-diagram.png)

#### BeanWrapper 基本使用 {#T-3.7.1}

编写测试 Bean：

```java
public class Pookie {

    private Integer id;

    private  String name;

    private int age;

    private Date birth;

    private List<Integer> nums;

    private Circle circle;

    // 省略 get/set ...
}
```

编写 BeanWrapper 测试类：

```java
@Test
public void test(){
    Pookie pookie = new Pookie();
    BeanWrapper wrapper = new BeanWrapperImpl(pookie);
    // 注册自定义的 PropertyEditor 到 BeanWrapper
    wrapper.registerCustomEditor(Point.class, new PointEditor());
    wrapper.registerCustomEditor(Date.class, new DateEditor());

    // 使用默认类型转换器
    wrapper.setPropertyValue("id", "1");
    Assert.assertEquals(1, pookie.getId().intValue());

    wrapper.setPropertyValue("birth", "2030-12-31 03:36:01");
    System.out.println(pookie.getBirth());

    // 设置 BeanWrapper 自动创建嵌套属性，否则会引发 NullValueInNestedPathException
    wrapper.setAutoGrowNestedPaths(true);
    wrapper.setPropertyValue("nums[0]", "123");
    wrapper.setPropertyValue("nums[1]", "456");
    System.out.println(pookie.getNums());

    // 通过注册的 PointEditor 完成 String -> Point 转换
    wrapper.setPropertyValue("circle.point", "5, 10");
    System.out.println(pookie.getCircle().getPoint());

    // 测试枚举转换：默认转换器中没有枚举转换，回退到 TypeConverterDelegate 默认转换(包含枚举)
    wrapper.setPropertyValue("color", "RED");
    System.out.println(pookie.getColor());
}
```

BeanWrapper 支持嵌套属性赋值，当存在嵌套属性时需要设置 `setAutoGrowNestedPaths(true)`

|表达式  |含义     |
|   ---   |   --- |
|name     |给属性name赋值，如果name是对象，将值作为该对象构造器的参数创建对象
|bean.name|属性bean是一个对象，给对象bean中的name赋值,需设置
|name[1]  |属性类型为array、list，给第n个下标赋值
|name{key}|属性为一个Map，指定key赋值，默认会创建LinkedHashMap


控制台输出：

```console
Tue Dec 31 03:36:01 CST 2030
[123, 456]
Point[x=5, y=10]
```

在本例中只注册了两个自定义类型转换器，但并没有 Integer 类型的转换器，因此在设置 `id`
属性值时使用的是默认内置的转换器，在设置 `Date` 属性和 `Circle` 属性时分别使用 `DateEditor` 和 `PointEditor` 自定义类型转换器。可通过 BeanWrapperImpl 的构造函数参数 `registerDefaultEditors` 来设置是否启用默认转换器，此外其它构造函数默认均开启内置转换器。

```java
/**
 * Create a new empty BeanWrapperImpl. Wrapped instance needs to be set afterwards.
 * Registers default editors.
 * @see #setWrappedInstance
 */
public BeanWrapperImpl() {
    this(true);
}

/**
 * Create a new empty BeanWrapperImpl. Wrapped instance needs to be set afterwards.
 * @param registerDefaultEditors whether to register default editors
 * (can be suppressed if the BeanWrapper won't need any type conversion)
 * @see #setWrappedInstance
 */
public BeanWrapperImpl(boolean registerDefaultEditors) {
    super(registerDefaultEditors);
}
```

当 BeanWrapperImpl 无法根据指定属性类型找到对应的自定义 `PropertyEditor` 或 `ConversionService` 时，如果已启用默认转换器，则使用默认转换器进行转换。默认转换器仅在需要时才创建，具体可参考 `org.springframework.beans.PropertyEditorRegistrySupport#getDefaultEditor`。

#### BeanWrapper 注册/查找类型转换器 {#T-3.7.2}

前文提到可以通过 `CustomEditorConfigurer` 向 Spring 容器中注册自定义 `PropertyEditor`，Spring 在实例化 Bean 时会返回一个包装类 `BeanWrapperImpl`，并且通过 `initBeanWrapper` 方法为 `BeanWrapper` 设置容器所持有的 `ConversionService` 和 `customPropertyEditors`，即向容器中注册的自定义转换器会在此设置到 `BeanWrapper`；由于 `BeanWrapperImpl` 继承了 `PropertyEditorRegistrySupport`，所以这些转换器的注册与查找等操作最终会委托给 `BeanWrapperImpl` 的父类来完成。

```java
// Instantiate the given bean using its default constructor.
protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) {
    try {
        Object beanInstance;
        final BeanFactory parent = this;
        if (System.getSecurityManager() != null) {
            beanInstance = AccessController.doPrivileged((PrivilegedAction<Object>) () ->
                    getInstantiationStrategy().instantiate(mbd, beanName, parent),
                    getAccessControlContext());
        }
        else {
            beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);
        }
        // 创建 Bean 的包装实现类
        BeanWrapper bw = new BeanWrapperImpl(beanInstance);
        // 初始化 BeanWrapper
        initBeanWrapper(bw);
        // 返回 Bean 的包装类
        return bw;
    }
    catch (Throwable ex) {
        throw new BeanCreationException(
                mbd.getResourceDescription(), beanName, "Instantiation of bean failed", ex);
    }
}
```

##### 初始化 BeanWrapper {#T-3.7.2.1}

```java
/**
 * Initialize the given BeanWrapper with the custom editors registered
 * with this factory. To be called for BeanWrappers that will create
 * and populate bean instances.
 * The default implementation delegates to {@link #registerCustomEditors}.
 * Can be overridden in subclasses.
 */
protected void initBeanWrapper(BeanWrapper bw) {
    // 设置容器持有的 ConversionService
    bw.setConversionService(getConversionService());
    // 向 beanWrapper 注册容器中的自定义转换器
    registerCustomEditors(bw);
}
```

##### 为 BeanWrapper 注册自定义转换器 {#T-3.7.2.2}

```java
/**
 * Initialize the given PropertyEditorRegistry with the custom editors
 * that have been registered with this BeanFactory.
 * To be called for BeanWrappers that will create and populate bean
 * instances, and for SimpleTypeConverter used for constructor argument
 * and factory method type conversion.
 */
protected void registerCustomEditors(PropertyEditorRegistry registry) {
    PropertyEditorRegistrySupport registrySupport =
            (registry instanceof PropertyEditorRegistrySupport ? (PropertyEditorRegistrySupport) registry : null);
    if (registrySupport != null) {
        registrySupport.useConfigValueEditors();
    }
    // 前文通过 CustomEditorConfigurer 注册的 PropertyEditorRegistrar 在这里进行注册
    if (!this.propertyEditorRegistrars.isEmpty()) {
        for (PropertyEditorRegistrar registrar : this.propertyEditorRegistrars) {
            try {
                registrar.registerCustomEditors(registry);
            }
            catch (BeanCreationException ex) {
                Throwable rootCause = ex.getMostSpecificCause();
                if (rootCause instanceof BeanCurrentlyInCreationException) {
                    BeanCreationException bce = (BeanCreationException) rootCause;
                    String bceBeanName = bce.getBeanName();
                    if (bceBeanName != null && isCurrentlyInCreation(bceBeanName)) {
                        if (logger.isDebugEnabled()) {
                            logger.debug("PropertyEditorRegistrar [" + registrar.getClass().getName() +
                                    "] failed because it tried to obtain currently created bean '" +
                                    ex.getBeanName() + "': " + ex.getMessage());
                        }
                        onSuppressedException(ex);
                        continue;
                    }
                }
                throw ex;
            }
        }
    }
    // 通过 CustomEditorConfigurer 的 CustomEditors 属性注册的自定义转换器在这里进行注册
    if (!this.customEditors.isEmpty()) {
        this.customEditors.forEach((requiredType, editorClass) ->
                registry.registerCustomEditor(requiredType, BeanUtils.instantiateClass(editorClass)));
    }
}
```

#### BeanWrapper 属性管理 {#T-3.7.3}

Spring 容器管理的 Bean 在实例化后会通过 `AbstractAutowireCapableBeanFactory#populateBean` 方法进行依赖注入，如果是 `@Autowired`、`@Value` 或 `@Resource` 等注解注入的属性会通过 `BeanPostProcessor` 进行解析和注入，这种情况会使用容器的 `AbstractBeanFactory#getTypeConverter` 获取的转换器进行值的转换，实际是 `SimpleTypeConverter`，在此不作分析；其它情况一般会在 `AbstractAutowireCapableBeanFactory#applyPropertyValues` 方法中通过 `BeanWrapperImpl#convertForProperty` 方法进行转换，最终在 `TypeConverterDelegate#convertIfNecessary` 方法中完成属性转换，然后使用 `AbstractPropertyAccessor#setPropertyValues` 完成属性注入。

##### Bean 属性类型转换 {#T-3.7.3.1}

前文提到 `BeanWrapperImpl` 实现了 `TypeConverter` 接口，该接口定义了将一个值转换为目标类型的功能。通过类图可以看到 `TypeConverterSupport` 对类型转换提供了默认实现，而 `TypeConverterSupport` 又将类型转换功能委托给 `TypeConverterDelegate` 来执行。最终在 `TypeConverterDelegate#convertIfNecessary` 方法中进行转换，该方法内部首先调用 `PropertyEditorRegistrySupport` 查找可用的 `PropertyEditor` 或 `ConversionService` 然后才进行转换，这个 `PropertyEditorRegistrySupport` 其实就是 `BeanWrapperImpl` 自己，原因是 `BeanWrapperImpl` 在其父类构造函数初始化时会 `new` 一个 `TypeConverterDelegate`，并且 `TypeConverterDelegate` 的构造函数参数 `PropertyEditorRegistrySupport` 传入的是 `this` ，即 `BeanWrapperImpl`。

```java
// BeanWrapperImpl 父类构造函数
protected AbstractNestablePropertyAccessor(boolean registerDefaultEditors) {
    if (registerDefaultEditors) {
        registerDefaultEditors();
    }
    this.typeConverterDelegate = new TypeConverterDelegate(this);
}
```

org.springframework.beans.TypeConverterSupport#convertIfNecessary

```java
public <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType) throws TypeMismatchException {
    return doConvert(value, requiredType, null, null);
}

private <T> T doConvert(@Nullable Object value, @Nullable Class<T> requiredType,
        @Nullable MethodParameter methodParam, @Nullable Field field) throws TypeMismatchException {

    Assert.state(this.typeConverterDelegate != null, "No TypeConverterDelegate");
    try {
        // 委托给 typeConverterDelegate 执行
        if (field != null) {
            return this.typeConverterDelegate.convertIfNecessary(value, requiredType, field);
        }
        else {
            return this.typeConverterDelegate.convertIfNecessary(value, requiredType, methodParam);
        }
    }
    catch (ConverterNotFoundException | IllegalStateException ex) {
        throw new ConversionNotSupportedException(value, requiredType, ex);
    }
    catch (ConversionException | IllegalArgumentException ex) {
        throw new TypeMismatchException(value, requiredType, ex);
    }
}
```

`TypeConverterDelegate` 实现了类型转换的功能，创建 `TypeConverterDelegate` 时需要一个 `PropertyEditorRegistrySupport` 对象，用于查找匹配的类型转换器。

```java
class TypeConverterDelegate {

    private static final Log logger = LogFactory.getLog(TypeConverterDelegate.class);

    private final PropertyEditorRegistrySupport propertyEditorRegistry;

    @Nullable
    private final Object targetObject;


    /**
     * Create a new TypeConverterDelegate for the given editor registry.
     * @param propertyEditorRegistry the editor registry to use
     */
    public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry) {
        this(propertyEditorRegistry, null);
    }

    /**
     * Create a new TypeConverterDelegate for the given editor registry and bean instance.
     * @param propertyEditorRegistry the editor registry to use
     * @param targetObject the target object to work on (as context that can be passed to editors)
     */
    public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, @Nullable Object targetObject) {
        this.propertyEditorRegistry = propertyEditorRegistry;
        this.targetObject = targetObject;
    }
}
```

**具体的属性转换过程 ★**

_注：由于 `TypeConverterDelegate#convertIfNecessary` 方法源码很长，此处进行分块说明。_

```java
/**
 * Convert the value to the required type (if necessary from a String),
 * for the specified property.
 * @param propertyName name of the property
 * @param oldValue the previous value, if available (may be {@code null})
 * @param newValue the proposed new value 等待转换的值
 * @param requiredType the type we must convert to 转换的目标类型
 * (or {@code null} if not known, for example in case of a collection element)
 * @param typeDescriptor the descriptor for the target property or field
 * @return the new value, possibly the result of type conversion
 * @throws IllegalArgumentException if type conversion failed
 */
public <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue,
        @Nullable Class<T> requiredType, @Nullable TypeDescriptor typeDescriptor) throws IllegalArgumentException {}
```

首先通过 `PropertyEditorRegistrySupport` 查找自定义的类型转换器 `PropertyEditor` 和 `ConversionService`。如果没有目标类型对应的 `PropertyEditor` 但存在自定义 `ConversionService`，则尝试用 `ConversionService` 进行类型转换；如果 `ConversionService`不能进行转换，这时尝试使用默认 `PropertyEditor` 进行转换。

```java
// Custom editor for this type?
PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);

ConversionFailedException conversionAttemptEx = null;

// No custom editor but custom ConversionService specified?
ConversionService conversionService = this.propertyEditorRegistry.getConversionService();

if (editor == null && conversionService != null && newValue != null && typeDescriptor != null) {
    TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);
    // 判断是否可以进行转换，即是否能找到对应的 Converter 转换器
    if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {
        try {
            // 使用 ConversionService 完成类型转换
            return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);
        }
        catch (ConversionFailedException ex) {
            // fallback to default conversion logic below
            conversionAttemptEx = ex;
        }
    }
}
```

如果目标类型存在自定义 `PropertyEditor` 或 属性值类型和目标类型不一致（对应上文 `ConversionService` 无法转换的情况），则在此使用 `PropertyEditor` 进行类型转换，当 `PropertyEditor` 为空时会先查找默认的类型转换器进行转换。

```java
Object convertedValue = newValue;

// Value not of required type?
if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {
    // 目标类型是 Collection 子类且属性值为 String 时，先将属性值转换为字符串数组(分割符为",")
    if (typeDescriptor != null && requiredType != null && Collection.class.isAssignableFrom(requiredType) &&
            convertedValue instanceof String) {
        TypeDescriptor elementTypeDesc = typeDescriptor.getElementTypeDescriptor();
        if (elementTypeDesc != null) {
            Class<?> elementType = elementTypeDesc.getType();
            // 将值转换为 String 数组
            if (Class.class == elementType || Enum.class.isAssignableFrom(elementType)) {
                convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);
            }
        }
    }
    // 查找 PropertyEditorRegistrySupport 中默认注册的类型转换器
    if (editor == null) {
        editor = findDefaultEditor(requiredType);
    }
    // 使用 PropertyEditor 进行类型转换
    convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);
}
```

使用 `PropertyEditor` 执行类型转换主要分三种情况处理：值类型不是字符串，值类型是字符串数组，值类型是字符串。

```java
// org.springframework.beans.TypeConverterDelegate#doConvertValue
// Convert the value to the required type (if necessary from a String), using the given property editor.
private Object doConvertValue(@Nullable Object oldValue, @Nullable Object newValue,
        @Nullable Class<?> requiredType, @Nullable PropertyEditor editor) {

    Object convertedValue = newValue;

    // 当值不是 String 类型时，使用 PropertyEditor -> setValue 和 getValue 进行转换
    if (editor != null && !(convertedValue instanceof String)) {
        // Not a String -> use PropertyEditor's setValue.
        // With standard PropertyEditors, this will return the very same object;
        // we just want to allow special PropertyEditors to override setValue
        // for type conversion from non-String values to the required type.
        try {
            editor.setValue(convertedValue);
            Object newConvertedValue = editor.getValue();
            if (newConvertedValue != convertedValue) {
                convertedValue = newConvertedValue;
                // Reset PropertyEditor: It already did a proper conversion.
                // Don't use it again for a setAsText call.
                editor = null;
            }
        }
        catch (Exception ex) {
            if (logger.isDebugEnabled()) {
                logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex);
            }
            // Swallow and proceed.
        }
    }

    Object returnValue = convertedValue;

    // 当值为字符串数组，但目标类型不是数组的时候，将值用","连接为字符串
    if (requiredType != null && !requiredType.isArray() && convertedValue instanceof String[]) {
        // Convert String array to a comma-separated String.
        // Only applies if no PropertyEditor converted the String array before.
        // The CSV String will be passed into a PropertyEditor's setAsText method, if any.
        if (logger.isTraceEnabled()) {
            logger.trace("Converting String array to comma-delimited String [" + convertedValue + "]");
        }
        convertedValue = StringUtils.arrayToCommaDelimitedString((String[]) convertedValue);
    }

    // 值为 String 类型，调用 PropertyEditor -> setAsText 进行转换
    if (convertedValue instanceof String) {
        if (editor != null) {
            // Use PropertyEditor's setAsText in case of a String value.
            if (logger.isTraceEnabled()) {
                logger.trace("Converting String to [" + requiredType + "] using property editor [" + editor + "]");
            }
            String newTextValue = (String) convertedValue;
            return doConvertTextValue(oldValue, newTextValue, editor);
        }
        else if (String.class == requiredType) {
            returnValue = convertedValue;
        }
    }

    return returnValue;
}

// 转换 String 类型的值，这里使用 oldValue 触发属性改变事件并将原值传递给监听器，然后再设置新值
private Object doConvertTextValue(@Nullable Object oldValue, String newTextValue, PropertyEditor editor) {
    try {
        // 这里使用oldValue，用于触发属性改变事件
        // {@see java.beans.PropertyEditorSupport#setValue}
        editor.setValue(oldValue);
    }
    catch (Exception ex) {
        if (logger.isDebugEnabled()) {
            logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex);
        }
        // Swallow and proceed.
    }
    // 使用 setAsText 处理字符串类型的属性转换
    editor.setAsText(newTextValue);
    return editor.getValue();
}
```

执行完属性转换后判断转换后的值和目标类型是否符合要求，如果不符合则继续处理。这里主要处理了集合类型、Number 类型、基本类型转 String、枚举类型等。

```java
// org.springframework.beans.TypeConverterDelegate#convertIfNecessary

boolean standardConversion = false;

if (requiredType != null) {
    // Try to apply some standard type conversion rules if appropriate.

    if (convertedValue != null) {
        if (Object.class == requiredType) {
            return (T) convertedValue;
        }
        // 目标类型为数组
        else if (requiredType.isArray()) {
            // Array required -> apply appropriate conversion of elements.
            if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {
                convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);
            }
            return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());
        }
        // 属性值类型为集合
        else if (convertedValue instanceof Collection) {
            // Convert elements to target type, if determined.
            convertedValue = convertToTypedCollection(
                    (Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor);
            standardConversion = true;
        }
        // 属性值类型为 Map
        else if (convertedValue instanceof Map) {
            // Convert keys and values to respective target type, if determined.
            convertedValue = convertToTypedMap(
                    (Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor);
            standardConversion = true;
        }
        // 属性值类型为数组且长度为1：直接返回单个数组元素
        if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {
            convertedValue = Array.get(convertedValue, 0);
            standardConversion = true;
        }
        // 目标类型为 String 且属性值为基本数据类型：直接调用 toString()
        if (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {
            // We can stringify any primitive value...
            return (T) convertedValue.toString();
        }
        // 转换后的值为 String 但目标类型不是 String
        else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {
            // 没有使用 ConversionService 进行转换的情况且目标类型不是枚举或接口
            if (conversionAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {
                try {
                    // 使用反射创建包装属性值的目标类型对象
                    Constructor<T> strCtor = requiredType.getConstructor(String.class);
                    return BeanUtils.instantiateClass(strCtor, convertedValue);
                }
                catch (NoSuchMethodException ex) {
                    // proceed with field lookup
                    if (logger.isTraceEnabled()) {
                        logger.trace("No String constructor found on type [" + requiredType.getName() + "]", ex);
                    }
                }
                catch (Exception ex) {
                    if (logger.isDebugEnabled()) {
                        logger.debug("Construction via String failed for type [" + requiredType.getName() + "]", ex);
                    }
                }
            }
            // 目标类型是枚举的情况
            String trimmedValue = ((String) convertedValue).trim();
            if (requiredType.isEnum() && "".equals(trimmedValue)) {
                // It's an empty enum identifier: reset the enum value to null.
                return null;
            }
            // 根据枚举名称转换为枚举对象
            convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);
            standardConversion = true;
        }
        // 转换后的值为 Number 且目标类型也为 Number：将值转换为具体的数据类型 如int/long/double
        else if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) {
            convertedValue = NumberUtils.convertNumberToTargetClass(
                    (Number) convertedValue, (Class<Number>) requiredType);
            standardConversion = true;
        }
    }
    // convertedValue = null
    else {
        // 目标类型为 Optional 且属性值为 Null：返回只含空值的Optional对象
        if (requiredType == Optional.class) {
            convertedValue = Optional.empty();
        }
    }

    // 属性值的类型于目标类型仍然不符
    if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {
        // 先前已经使用 ConversionService 转换，直接抛出异常
        if (conversionAttemptEx != null) {
            // Original exception from former ConversionService call above...
            throw conversionAttemptEx;
        }
        // 还没有使用 ConversionService 转换，进行最后的转换尝试
        else if (conversionService != null && typeDescriptor != null) {
            // ConversionService not tried before, probably custom editor found
            // but editor couldn't produce the required type...
            TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);
            if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {
                return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);
            }
        }

        // 没有注册 ConversionService 则按照相应描述格式抛出异常 
        // Definitely doesn't match: throw IllegalArgumentException/IllegalStateException
        StringBuilder msg = new StringBuilder();
        msg.append("Cannot convert value of type '").append(ClassUtils.getDescriptiveType(newValue));
        msg.append("' to required type '").append(ClassUtils.getQualifiedName(requiredType)).append("'");
        if (propertyName != null) {
            msg.append(" for property '").append(propertyName).append("'");
        }
        if (editor != null) {
            msg.append(": PropertyEditor [").append(editor.getClass().getName()).append(
                    "] returned inappropriate value of type '").append(
                    ClassUtils.getDescriptiveType(convertedValue)).append("'");
            throw new IllegalArgumentException(msg.toString());
        }
        else {
            msg.append(": no matching editors or conversion strategy found");
            throw new IllegalStateException(msg.toString());
        }
    }
}

// requiredType = null
if (conversionAttemptEx != null) {
    if (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) {
        throw conversionAttemptEx;
    }
    logger.debug("Original ConversionService attempt failed - ignored since " +
            "PropertyEditor based conversion eventually succeeded", conversionAttemptEx);
}

return (T) convertedValue;
    
```

##### Bean 属性注入/访问 {#T-3.7.3.2}

`PropertyAccessor` 接口定义了属性访问的功能。通过实现 `setPropertyValue` 和 `getPropertyValue` 方法实现对象属性的赋值和访问。`BeanWrapperImpl` 的父类 `AbstractPropertyAccessor` 实现了 `PropertyAccessor` 接口，不过没有实现 `setPropertyValue` 和 `getPropertyValue`，而是单独提供了一个 `setPropertyValues` 的方法用于批量设置属性值，同时可以通过 `ignoreUnknown` 和 `ignoreInvalid` 参数忽略未知的属性。

```java
// org.springframework.beans.AbstractPropertyAccessor#setPropertyValues
public void setPropertyValues(PropertyValues pvs, boolean ignoreUnknown, boolean ignoreInvalid)
        throws BeansException {

    List<PropertyAccessException> propertyAccessExceptions = null;
    List<PropertyValue> propertyValues = (pvs instanceof MutablePropertyValues ?
            ((MutablePropertyValues) pvs).getPropertyValueList() : Arrays.asList(pvs.getPropertyValues()));
    for (PropertyValue pv : propertyValues) {
        try {
            // This method may throw any BeansException, which won't be caught
            // here, if there is a critical failure such as no matching field.
            // We can attempt to deal only with less serious exceptions.
            setPropertyValue(pv);
        }
        catch (NotWritablePropertyException ex) {
            if (!ignoreUnknown) {
                throw ex;
            }
            // Otherwise, just ignore it and continue...
        }
        catch (NullValueInNestedPathException ex) {
            if (!ignoreInvalid) {
                throw ex;
            }
            // Otherwise, just ignore it and continue...
        }
        catch (PropertyAccessException ex) {
            if (propertyAccessExceptions == null) {
                propertyAccessExceptions = new LinkedList<>();
            }
            propertyAccessExceptions.add(ex);
        }
    }

    // If we encountered individual exceptions, throw the composite exception.
    if (propertyAccessExceptions != null) {
        PropertyAccessException[] paeArray =
                propertyAccessExceptions.toArray(new PropertyAccessException[propertyAccessExceptions.size()]);
        throw new PropertyBatchUpdateException(paeArray);
    }
}
```

在 `BeanWrapperImpl` 的直属父类 `AbstractNestablePropertyAccessor` 类中实现了 `setPropertyValue` 和 `getPropertyValue` 方法。

```java
// org.springframework.beans.AbstractNestablePropertyAccessor#setPropertyValue
public void setPropertyValue(String propertyName, @Nullable Object value) throws BeansException {
    AbstractNestablePropertyAccessor nestedPa;
    try {
        // 用于解决 name.map[key] 类型的属性注入
        nestedPa = getPropertyAccessorForPropertyPath(propertyName);
    }
    catch (NotReadablePropertyException ex) {
        throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,
                "Nested property in path '" + propertyName + "' does not exist", ex);
    }
    PropertyTokenHolder tokens = getPropertyNameTokens(getFinalPath(nestedPa, propertyName));
    // 为属性赋值
    nestedPa.setPropertyValue(tokens, new PropertyValue(propertyName, value));
}
```

由于存在嵌套属性赋值的情况，对于嵌套的处理其实只需要对嵌套的最底层进行类型转换，上层创建默认的值然后 set 到上层对象的属性中。在这里 Spring 使用递归来解决这个问题，创建每一层属性的对象值，使用 `BeanWrapper` 包装该对象，那么又是一个 `BeanWrapperImpl` 的赋值流程。

```java
// org.springframework.beans.AbstractNestablePropertyAccessor#getPropertyAccessorForPropertyPath
// 例如: beanWrapper.setPropertyValue("hat.colors[green]", "绿色"); 
// hat 是对象的引用属性，colors 是对象 hat 的引用 Map
protected AbstractNestablePropertyAccessor getPropertyAccessorForPropertyPath(String propertyPath) {
    int pos = PropertyAccessorUtils.getFirstNestedPropertySeparatorIndex(propertyPath);
    // pos > -1 进行递归处理
    // Handle nested properties recursively.
    if (pos > -1) {
        // 解析出上层的属性名：hat
        String nestedProperty = propertyPath.substring(0, pos);
        // 截取剩下的属性路径：colors[green]
        String nestedPath = propertyPath.substring(pos + 1);
        // 针对上层属性创建 AbstractNestablePropertyAccessor 包装该对象并将其赋值到所依赖的对象
        AbstractNestablePropertyAccessor nestedPa = getNestedPropertyAccessor(nestedProperty);
        // 递归调用直到完成最终的属性注入
        return nestedPa.getPropertyAccessorForPropertyPath(nestedPath);
    }
    // 不存在嵌套属性，直接返回 AbstractNestablePropertyAccessor 自己
    else {
        return this;
    }
}
```

看下递归的内部实现，在 `getNestedPropertyAccessor` 完成对外层属性的初始化并将该值赋值到所依赖的对象中，然后使用 `BeanWrapper` 封装属性对象，后续走属性对象的赋值流程。

```java
// org.springframework.beans.AbstractNestablePropertyAccessor#getNestedPropertyAccessor
// Retrieve a Property accessor for the given nested property. Create a new one if not found in the cache.
private AbstractNestablePropertyAccessor getNestedPropertyAccessor(String nestedProperty) {
    if (this.nestedPropertyAccessors == null) {
        this.nestedPropertyAccessors = new HashMap<>();
    }
    // Get value of bean property.
    PropertyTokenHolder tokens = getPropertyNameTokens(nestedProperty);
    String canonicalName = tokens.canonicalName;
    Object value = getPropertyValue(tokens);
    // 如果属性对象为空，这里使用反射创建属性对象并将该对象 set 到宿主对象中
    if (value == null || (value instanceof Optional && !((Optional) value).isPresent())) {
        // 如果允许嵌套属性赋值：{@see org.springframework.beans.ConfigurablePropertyAccessor#setAutoGrowNestedPaths}
        if (isAutoGrowNestedPaths()) {
            value = setDefaultValue(tokens);
        }
        // 不允许嵌套属性赋值则抛出异常
        else {
            throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + canonicalName);
        }
    }

    // Lookup cached sub-PropertyAccessor, create new one if not found.
    // 查找当前属性对象嵌套的子属性对象，没有则进行创建
    AbstractNestablePropertyAccessor nestedPa = this.nestedPropertyAccessors.get(canonicalName);
    if (nestedPa == null || nestedPa.getWrappedInstance() != ObjectUtils.unwrapOptional(value)) {
        if (logger.isTraceEnabled()) {
            logger.trace("Creating new nested " + getClass().getSimpleName() + " for property '" + canonicalName + "'");
        }
        // 使用 BeanWrapper 包装 子属性对象
        nestedPa = newNestedPropertyAccessor(value, this.nestedPath + canonicalName + NESTED_PROPERTY_SEPARATOR);
        // Inherit all type-specific PropertyEditors.
        // 继承外层对象的类型转换器
        copyDefaultEditorsTo(nestedPa);
        copyCustomEditorsTo(nestedPa, canonicalName);
        this.nestedPropertyAccessors.put(canonicalName, nestedPa);
    }
    else {
        if (logger.isTraceEnabled()) {
            logger.trace("Using cached nested property accessor for property '" + canonicalName + "'");
        }
    }
    // 返回包装对象 BeanWrapper，接下来就是对属性对象的递归赋值
    return nestedPa;
}
```

创建属性对象，并将该对象 set 到宿主对象。因为对象是指针引用的，所以在这步已经完成对宿主对象的属性赋值，接下来的流程只要对属性对象中的依赖属性进行赋值。

```java
// org.springframework.beans.AbstractNestablePropertyAccessor#setDefaultValue
private Object setDefaultValue(PropertyTokenHolder tokens) {
    // 创建对应类型的默认值
    PropertyValue pv = createDefaultPropertyValue(tokens);
    // 将值设置到宿主对象：过程中会应用宿主对象中的类型转换器对值进行转换
    setPropertyValue(tokens, pv);
    // 获取转换后的属性值
    Object defaultValue = getPropertyValue(tokens);
    Assert.state(defaultValue != null, "Default value must not be null");
    return defaultValue;
}
```

使用递归解决了嵌套属性赋值的问题，那么接下来就是针对底层 `BeanWrapperImpl` 的属性赋值流程。

```java
// org.springframework.beans.AbstractNestablePropertyAccessor#setPropertyValue
protected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {
    // 解决集合 Map 类型的赋值
    if (tokens.keys != null) {
        processKeyedProperty(tokens, pv);
    }
    // 非 Map 属性赋值
    else {
        processLocalProperty(tokens, pv);
    }
}
```

在 `processLocalProperty` 方法中，首先通过子类获取属性处理器 `PropertyHandler`，然后判断属性值是否已经执行类型转换，如果没有再次调用类型转换器进行转换，如果已经完成类型转换，直接获取转换后的值。最后通过 `PropertyHandler` 对属性进行赋值，实际是通过反射调用 `writeMethod` 进行赋值。

```java
// org.springframework.beans.AbstractNestablePropertyAccessor#processLocalProperty
private void processLocalProperty(PropertyTokenHolder tokens, PropertyValue pv) {
    
    // 首先获取属性处理器
    PropertyHandler ph = getLocalPropertyHandler(tokens.actualName);
    
    if (ph == null || !ph.isWritable()) {
        if (pv.isOptional()) {
            if (logger.isDebugEnabled()) {
                logger.debug("Ignoring optional value for property '" + tokens.actualName +
                        "' - property not found on bean class [" + getRootClass().getName() + "]");
            }
            return;
        }
        else {
            throw createNotWritablePropertyException(tokens.canonicalName);
        }
    }

    Object oldValue = null;
    try {
        Object originalValue = pv.getValue();
        Object valueToApply = originalValue;
        if (!Boolean.FALSE.equals(pv.conversionNecessary)) {
            // 如果已经完成类型转换，直接获取类型转换后的值
            if (pv.isConverted()) {
                valueToApply = pv.getConvertedValue();
            }
            // 还未完成类型转换的，再次调用类型转换器进行转换
            else {
                if (isExtractOldValueForEditor() && ph.isReadable()) {
                    try {
                        oldValue = ph.getValue();
                    }
                    catch (Exception ex) {
                        if (ex instanceof PrivilegedActionException) {
                            ex = ((PrivilegedActionException) ex).getException();
                        }
                        if (logger.isDebugEnabled()) {
                            logger.debug("Could not read previous value of property '" +
                                    this.nestedPath + tokens.canonicalName + "'", ex);
                        }
                    }
                }
                // 需要进行转换的，再次进行属性类型转换
                valueToApply = convertForProperty(
                        tokens.canonicalName, oldValue, originalValue, ph.toTypeDescriptor());
            }
            pv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);
        }
        // 通过反射调用目标对象的 writeMethod 对属性赋值
        ph.setValue(valueToApply);
    }
    // 省略后面异常捕获
    catch (Exception ex) {
        throw ex;
    }
}
```

对属性的访问和设置 Spring 进行了更小粒度的封装，提供了 `PropertyHandler` 抽象类。为什么在这里进行抽象? 从 `PropertyHandler` 的两个实现：`BeanPropertyHandler` 和 `FieldPropertyHandler` 可以得出访问属性有两种方式：一种是通过 `getter` 和 `setter` 方法，另一种是没有 `getter` 和 `setter` 而是通过反射来访问。

```java
// org.springframework.beans.BeanWrapperImpl#getLocalPropertyHandler
protected BeanPropertyHandler getLocalPropertyHandler(String propertyName) {
    PropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(propertyName);
    if (pd != null) {
        return new BeanPropertyHandler(pd);
    }
    return null;
}
```

`BeanWrapperImpl` 提供了 `BeanPropertyHandler`，而 `BeanPropertyHandler` 提供对 `setter` 和 `getter` 的访问。

```java
// org.springframework.beans.BeanWrapperImpl.BeanPropertyHandler
private class BeanPropertyHandler extends PropertyHandler {

    private final PropertyDescriptor pd;

    public BeanPropertyHandler(PropertyDescriptor pd) {
        super(pd.getPropertyType(), pd.getReadMethod() != null, pd.getWriteMethod() != null);
        this.pd = pd;
    }

    @Override
    public ResolvableType getResolvableType() {
        return ResolvableType.forMethodReturnType(this.pd.getReadMethod());
    }

    @Override
    public TypeDescriptor toTypeDescriptor() {
        return new TypeDescriptor(property(this.pd));
    }

    @Override
    @Nullable
    public TypeDescriptor nested(int level) {
        return TypeDescriptor.nested(property(pd), level);
    }

    @Override
    @Nullable
    public Object getValue() throws Exception {
        final Method readMethod = this.pd.getReadMethod();
        if (System.getSecurityManager() != null) {
            AccessController.doPrivileged((PrivilegedAction<Object>) () -> {
                ReflectionUtils.makeAccessible(readMethod);
                return null;
            });
            try {
                return AccessController.doPrivileged((PrivilegedExceptionAction<Object>) () ->
                        readMethod.invoke(getWrappedInstance(), (Object[]) null), acc);
            }
            catch (PrivilegedActionException pae) {
                throw pae.getException();
            }
        }
        else {
            ReflectionUtils.makeAccessible(readMethod);
            return readMethod.invoke(getWrappedInstance(), (Object[]) null);
        }
    }

    @Override
    public void setValue(final @Nullable Object value) throws Exception {
        final Method writeMethod = (this.pd instanceof GenericTypeAwarePropertyDescriptor ?
                ((GenericTypeAwarePropertyDescriptor) this.pd).getWriteMethodForActualAccess() :
                this.pd.getWriteMethod());
        if (System.getSecurityManager() != null) {
            AccessController.doPrivileged((PrivilegedAction<Object>) () -> {
                ReflectionUtils.makeAccessible(writeMethod);
                return null;
            });
            try {
                AccessController.doPrivileged((PrivilegedExceptionAction<Object>) () ->
                        writeMethod.invoke(getWrappedInstance(), value), acc);
            }
            catch (PrivilegedActionException ex) {
                throw ex.getException();
            }
        }
        else {
            ReflectionUtils.makeAccessible(writeMethod);
            writeMethod.invoke(getWrappedInstance(), value);
        }
    }
}
```

`AbstractNestablePropertyAccessor` 的另一个实现类 `DirectFieldAccessor`，专门用于给字段赋值，不依赖 `setter` 和 `getter`。那么这个是怎么实现的? 看源码发现 `DirectFieldAccessor` 提供一个 `PropertyHandler` 的实现类，通过 `Field` 反射实现 `getter/setter`。

```java
// org.springframework.beans.DirectFieldAccessor.FieldPropertyHandler
private class FieldPropertyHandler extends PropertyHandler {

    private final Field field;

    public FieldPropertyHandler(Field field) {
        super(field.getType(), true, true);
        this.field = field;
    }

    @Override
    public TypeDescriptor toTypeDescriptor() {
        return new TypeDescriptor(this.field);
    }

    @Override
    public ResolvableType getResolvableType() {
        return ResolvableType.forField(this.field);
    }

    @Override
    @Nullable
    public TypeDescriptor nested(int level) {
        return TypeDescriptor.nested(this.field, level);
    }

    @Override
    @Nullable
    public Object getValue() throws Exception {
        try {
            ReflectionUtils.makeAccessible(this.field);
            return this.field.get(getWrappedInstance());
        }

        catch (IllegalAccessException ex) {
            throw new InvalidPropertyException(getWrappedClass(),
                    this.field.getName(), "Field is not accessible", ex);
        }
    }

    @Override
    public void setValue(@Nullable Object value) throws Exception {
        try {
            ReflectionUtils.makeAccessible(this.field);
            this.field.set(getWrappedInstance(), value);
        }
        catch (IllegalAccessException ex) {
            throw new InvalidPropertyException(getWrappedClass(), this.field.getName(),
                    "Field is not accessible", ex);
        }
    }
}
```

### 基于 PropertyEditor 类型转换的缺陷 {#T-3.8}

基于 `PropertyEditor` 的类型转换作为一种古老的、遗留下来的方式，是具有一些设计缺陷的：

1. 只能完成字符串到 Java 类型的转换，并不能完成任意类型之间的转换。 
 
2. 由于 `PropertyEditor` 不是线程安全的，因此每次类型转换都需要创建一个新的 `PropertyEdtitor` 对象。在 Spring 老版本源码中，底层会使用 `synchronized` 对转换逻辑进行同步，新版本已经删除了同步代码块，改为每次类型转换创建新的转换器对象。

虽然自 Spring 3.0 起提供了新一代的类型转换接口 `ConversionService`，但是此部分机制一直得以**保留**，保证了**向下兼容**。

## Spring 3.0 类型转换接口 Converter {#T-4}

为了解决 `PropertyEditor` 作为类型转换方式的设计缺陷，Spring 3.0 版本重新设计了一套类型转换接口，其中主要包括：

+ `Converter<S, T>`：Source -> Target 类型转换接口，适用于 `1 : 1` 转换
    + StringToPropertiesConverter：将 String 类型转换为 Properties
    + StringToBooleanConverter：将 String 类型转换为 Boolean
    + EnumToIntegerConverter：将 Enum 类型转换为 Integer

+ `ConverterFactory<S, R>`：Source -> R 类型转换接口，适用于 `1 : N` 转换
    + StringToEnumConverterFactory：将 String 类型转任意 Enum
    + StringToNumberConverterFactory：将 String 类型转为任意数字（如: `int、long、double`）
    + NumberToNumberConverterFactory：数字类型转为数字类型（如: `int -> long`）

+ `GenericConverter`：更为通用的类型转换接口，适用于 `N : N` 转换
    + ObjectToCollectionConverter：任意集合类型转为任意集合类型（如 `List<String>` -> `List<Integer> / Set<Integer>`）
    + CollectionToArrayConverter：集合类型转数组类型
    + MapToMapConverter：不同类型的 Map 转换

+ `ConditionalConverter`：条件转换接口。可与上面3个接口组合使用，提供**前置条件**判断验证

重新设计的这套接口，解决了 `PropertyEditor` 做类型转换存在的所有缺陷，且具有非常高的灵活性和可扩展性。但每个接口单独来看均具有一定的局限性，只有使用**组合拳**才具有最大威力。

## Spring 3.0 转换服务接口 ConversionService {#T-5}

Spring 3.0 新增的三个类型转换接口 `Converter、ConverterFactory、GenericConverter` 均致力于完成类型转换，但对于使用者而言掌握这三套体系无疑成本太高，因此就有了 `ConversionService` 用于整合这三个接口，统一化接口操作。`ConversionService` 也是 Spring 3.0 新增的用于**统一化**底层不同类型转换器之间的差异，对外提供统一服务，也被称为类型转换**门面接口**。从接口名称 `xxxService` 也能看出其设计思路，它主要有两大实现：

1.`GenericConversionService`：提供通用模版实现，如转换器的注册、删除、匹配查找等，但并不内置转换器具体实现。

2.`DefaultConversionService`：继承自 `GenericConversionService`，在它基础上默认注册了非常多的内置转换器实现，从而能够实现**绝大部分**的类型转换需求。

`ConversionService` 贯穿于 Spring 上下文 `ApplicationContext` 的多项功能，包括但不限于：BeanWrapper 处理 Bean 属性、DataBinder 数据绑定、PropertySource 外部化属性处理等。

> 说明：很多小伙伴问 WebConversionService 是什么场景下使用？它并非 Spirng Framework 的 API，而是属于 Spring Boot 提供的增强，且起始于 2.x 版本，这点需引起注意。

## Spring 3.0 类型转换整合格式化 Formatter {#T-6}

Spring 3.0 还新增了一个 `Formatter<T>` 接口，作为将 Object 格式化为类型 T 的解析器。从语义上理解它也具有数据转换的作用，相较于 `Converter<S,T>` 它强调的是**格式化**，因此一般用于时间/日期、数字（小数、分数、科学计数法）、货币等场景，举例实现：

+ `DurationFormatter`：字符串和 `Duration` 类型的互转
+ `CurrencyUnitFormatter`：字符串和 `javax.money.CurrencyUnit` 货币类型互转
+ `DateFormatter`：字符串和 `java.util.Date` 类型互转。

为了和类型转换服务 `ConversionService` 完成整合并对外提供统一的 API，Spring 提供了 `FormattingConversionService` 和 `DefaultFormattingConversionService` 专门用于整合 `Converter` 和 `Formatter`，使得两者具有一致的编程体验，对开发者更加友好。

---

## 参考 {#T-7}

+ [Spring类型转换器(一)](https://www.jianshu.com/p/3a5f2a65a985)
+ [深入分析Spring中的类型转换与校验](https://www.jianshu.com/p/e2baa8d87029)
+ [揭秘Spring类型转换 - 框架设计的基石](https://blog.csdn.net/f641385712/article/details/110304588)

---
