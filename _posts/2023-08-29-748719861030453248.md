---
layout: post
title: Spring 数据类型转换：Converter
date: 2023-08-29
category: Spring
tags: [Spring Converter]
excerpt: 
---

## Spring 3.0 Converter

**`Converter`** 声明了一个从源数据类型转换为目标数据类型的方法，适用于 `1 : 1` 类型转换，例如 `String` -> `Boolean`。

```java
// A converter converts a source object of type S to a target of type T.
@FunctionalInterface
public interface Converter<S, T> {
   // Convert the source object of type S to target type T.
   T convert(S source);
}
```

**`ConverterFactory`** 作为 `Converter` 工厂接口，支持从一个源类型转换为一个目标类型对应的子类型，适用于 `1 : N` 类型转换，例如 `String` -> `Enum`、`String` -> `Number`、`Number` -> `Number`。

```java
// A factory for "ranged" converters that can convert objects from S to subtypes of R.
public interface ConverterFactory<S, R> {
   // Get the converter to convert from S to target type T, where T is also an instance of R.
   <T extends R> Converter<S, T> getConverter(Class<T> targetType);
}
```

**`GenericConverter`** 是更为通用的转换接口，支持多个类型对之间的转换，适用于 `N : N` 转换，例如 `Object` -> `Object`、`Collection` -> `Array`。

```java
/**
 * Generic converter interface for converting between two or more types.
 *
 * This is the most flexible of the Converter SPI interfaces, but also the most complex.
 * It is flexible in that a GenericConverter may support converting between multiple source/target
 * type pairs (see {@link #getConvertibleTypes()}. In addition, GenericConverter implementations
 * have access to source/target {@link TypeDescriptor field context} during the type conversion
 * process. This allows for resolving source and target field metadata such as annotations and
 * generics information, which can be used to influence the conversion logic.
 *
 * This interface should generally not be used when the simpler {@link Converter} or
 * {@link ConverterFactory} interface is sufficient.
 */
public interface GenericConverter {

    /**
     * Return the source and target types that this converter can convert between.
     * Each entry is a convertible source-to-target type pair.
     * For {@link ConditionalConverter conditional converters} this method may return
     * {@code null} to indicate all source-to-target pairs should be considered.
     */
    @Nullable
    Set<ConvertiblePair> getConvertibleTypes();

    /**
     * Convert the source object to the targetType described by the {@code TypeDescriptor}.
     * @param source the source object to convert (may be {@code null})
     * @param sourceType the type descriptor of the field we are converting from
     * @param targetType the type descriptor of the field we are converting to
     * @return the converted object
     */
    @Nullable
    Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType);

}
```

**`ConditionalGenericConverter`** 提供基于前置条件判断的类型转换接口，通常与上述三个接口组合使用。

```java
/**
 * Allows a {@link Converter}, {@link GenericConverter} or {@link ConverterFactory} to
 * conditionally execute based on attributes of the {@code source} and {@code target}
 * {@link TypeDescriptor}.
 *
 * Often used to selectively match custom conversion logic based on the presence of a
 * field or class-level characteristic, such as an annotation or method. For example, when
 * converting from a String field to a Date field, an implementation might return
 * {@code true} if the target field has also been annotated with {@code @DateTimeFormat}.
 *
 * As another example, when converting from a String field to an {@code Account} field,
 * an implementation might return {@code true} if the target Account class defines a
 * {@code public static findAccount(String)} method.
 */
public interface ConditionalConverter {

    /**
     * Should the conversion from {@code sourceType} to {@code targetType} currently under
     * consideration be selected?
     * @param sourceType the type descriptor of the field we are converting from
     * @param targetType the type descriptor of the field we are converting to
     * @return true if conversion should be performed, false otherwise
     */
    boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType);

}
```

## Spring 3.0 ConversionService

![spring-conversion-service-class-diagram](https://s1.imagehub.cc/images/2023/09/02/spring-conversion-service-class-diagram.png)

`ConversionService` 是策略模式的一种实现，主要用于整合 `Converter、ConverterFactory、GenericConverter` 这三个接口，对外提供统一的类型转换服务，其主要实现有下面两种：

1.`GenericConversionService`：提供通用模版实现，如转换器的注册、删除、匹配查找等，但并不内置转换器具体实现。

2.`DefaultConversionService`：继承自 `GenericConversionService`，在它基础上默认注册了非常多的内置转换器实现，从而能够实现**绝大部分**的类型转换需求。

```java
/**
 * A service interface for type conversion. This is the entry point into the convert system.
 * Call {@link #convert(Object, Class)} to perform a thread-safe type conversion using this system.
 */
public interface ConversionService {

    /**
     * Return {@code true} if objects of {@code sourceType} can be converted to the {@code targetType}.
     * If this method returns {@code true}, it means {@link #convert(Object, Class)} is capable
     * of converting an instance of {@code sourceType} to {@code targetType}.
     * Special note on collections, arrays, and maps types:
     * For conversion between collection, array, and map types, this method will return {@code true}
     * even though a convert invocation may still generate a {@link ConversionException} if the
     * underlying elements are not convertible. Callers are expected to handle this exceptional case
     * when working with collections and maps.
     * @param sourceType the source type to convert from (may be {@code null} if source is {@code null})
     * @param targetType the target type to convert to (required)
     * @return {@code true} if a conversion can be performed, {@code false} if not
     * @throws IllegalArgumentException if {@code targetType} is {@code null}
     */
    boolean canConvert(@Nullable Class<?> sourceType, Class<?> targetType);

    /**
     * Return {@code true} if objects of {@code sourceType} can be converted to the {@code targetType}.
     * The TypeDescriptors provide additional context about the source and target locations
     * where conversion would occur, often object fields or property locations.
     * If this method returns {@code true}, it means {@link #convert(Object, TypeDescriptor, TypeDescriptor)}
     * is capable of converting an instance of {@code sourceType} to {@code targetType}.
     * Special note on collections, arrays, and maps types:
     * For conversion between collection, array, and map types, this method will return {@code true}
     * even though a convert invocation may still generate a {@link ConversionException} if the
     * underlying elements are not convertible. Callers are expected to handle this exceptional case
     * when working with collections and maps.
     * @param sourceType context about the source type to convert from
     * (may be {@code null} if source is {@code null})
     * @param targetType context about the target type to convert to (required)
     * @return {@code true} if a conversion can be performed between the source and target types,
     * {@code false} if not
     * @throws IllegalArgumentException – if targetType is null
     */
    boolean canConvert(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType);

    /**
     * Convert the given {@code source} to the specified {@code targetType}.
     * @param source the source object to convert (may be {@code null})
     * @param targetType the target type to convert to (required)
     * @return the converted object, an instance of targetType
     * @throws ConversionException if a conversion exception occurred
     * @throws IllegalArgumentException if targetType is {@code null}
     */
    @Nullable
    <T> T convert(@Nullable Object source, Class<T> targetType);

    /**
     * Convert the given {@code source} to the specified {@code targetType}.
     * The TypeDescriptors provide additional context about the source and target locations
     * where conversion will occur, often object fields or property locations.
     * @param source the source object to convert (may be {@code null})
     * @param sourceType context about the source type to convert from
     * (may be {@code null} if source is {@code null})
     * @param targetType context about the target type to convert to (required)
     * @return the converted object, an instance of {@link TypeDescriptor#getObjectType() targetType}
     * @throws ConversionException if a conversion exception occurred
     * @throws IllegalArgumentException if targetType is {@code null},
     * or {@code sourceType} is {@code null} but source is not {@code null}
     */
    @Nullable
    Object convert(@Nullable Object source, @Nullable TypeDescriptor sourceType, TypeDescriptor targetType);

}
```

**`ConverterRegistry`** 用于注册和管理各种类型转换器。

```java
/**
 * For registering converters with a type conversion system.
 */
public interface ConverterRegistry {

    /**
     * Add a plain converter to this registry.
     * The convertible source/target type pair is derived from the Converter's parameterized types.
     * 
     * 将纯转换器添加到此注册表。可转换的源/目标类型对派生自 Converter 的泛型化类型。
     * 
     * @throws IllegalArgumentException if the parameterized types could not be resolved
     */
    void addConverter(Converter<?, ?> converter);

    /**
     * Add a plain converter to this registry.
     * The convertible source/target type pair is specified explicitly.
     * Allows for a Converter to be reused for multiple distinct pairs without
     * having to create a Converter class for each pair.
     * 
     * 将纯转换器添加到此注册表，明确指定了可转换的源/目标类型对。
     * 允许对多个不同的类型对儿重用 Converter，而不必为每个类型对儿创建 Converter 类。
     * 
     * 默认添加 Converter 是按照泛型指定类型对儿，该方法可明确指定转换的具体类型。
     * 例如：Converter<String, Enum> 默认只会添加 String -> Enum 类型对儿
     * 通过该方法可指定为 String -> Color(具体的枚举类) 的类型对儿（其实不用指定也可以转换） 
     */ 
    <S, T> void addConverter(Class<S> sourceType, Class<T> targetType, Converter<? super S, ? extends T> converter);

    /**
     * Add a generic converter to this registry.
     */
    void addConverter(GenericConverter converter);

    /**
     * Add a ranged converter factory to this registry.
     * The convertible source/target type pair is derived from the ConverterFactory's parameterized types.
     * 
     * 将一个范围转换器工厂添加到此注册表。可转换的源/目标类型对派生自 ConverterFactory 的泛型化类型。
     * 
     * @throws IllegalArgumentException if the parameterized types could not be resolved
     */
    void addConverterFactory(ConverterFactory<?, ?> factory);

    /**
     * Remove any converters from {@code sourceType} to {@code targetType}.
     */
    void removeConvertible(Class<?> sourceType, Class<?> targetType);
}
```

**`GenericConversionService`** 是适用于大多数环境的基本转换服务的实现，通过 `ConfigurableConversionService` 接口间接实现了 `ConversionService`、`ConverterRegistry`，实现了转换器注册/查找以及类型转换的功能，并将功能细节委托给了内部类 `Converters` 实现。`Converters` 只接收 `GenericConverter` 类型的转换器，因此 `GenericConversionService` 提供了两个适配器 `ConverterAdapter` 和 `ConverterFactoryAdapter` 来完成 `Converter` 到 `GenericConverter`、`ConverterFactory` 到 `GenericConverter` 的转换。

```java
// Adapts a Converter to a GenericConverter.
// org.springframework.core.convert.support.GenericConversionService.ConverterAdapter
private final class ConverterAdapter implements ConditionalGenericConverter {

    // 被包装的 Converter
    private final Converter<Object, Object> converter;

    // 封装的类型对儿：源类型 -> 目类型
    private final ConvertiblePair typeInfo;

    private final ResolvableType targetType;

    public ConverterAdapter(Converter<?, ?> converter, ResolvableType sourceType, ResolvableType targetType) {
        this.converter = (Converter<Object, Object>) converter;
        this.typeInfo = new ConvertiblePair(sourceType.resolve(Object.class), targetType.resolve(Object.class));
        this.targetType = targetType;
    }

    @Override
    public Set<ConvertiblePair> getConvertibleTypes() {
        return Collections.singleton(this.typeInfo);
    }

    // 实现 ConditionalGenericConverter 的前置条件验证
    @Override
    public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {
        // Check raw type first...
        // 判断当前转换器可转换类型与目标类型是否匹配.
        if (this.typeInfo.getTargetType() != targetType.getObjectType()) {
            return false;
        }
        // Full check for complex generic type match required?
        ResolvableType rt = targetType.getResolvableType();
        if (!(rt.getType() instanceof Class) && !rt.isAssignableFrom(this.targetType) &&
                !this.targetType.hasUnresolvableGenerics()) {
            return false;
        }
        // 如果被包装的 Converter 同时实现了 ConditionalConverter 则执行 matches 验证，否则返回 true
        return !(this.converter instanceof ConditionalConverter) ||
                ((ConditionalConverter) this.converter).matches(sourceType, targetType);
    }

    @Override
    public Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {
        if (source == null) {
            // 如果待转换对象为 Null 且 目标类型是 Optional，则返回包含空值的 Optional 对象，否则返回 Null
            return convertNullSource(sourceType, targetType);
        }
        // 调用包装的 Converter 进行转换
        return this.converter.convert(source);
    }

    @Override
    public String toString() {
        return (this.typeInfo + " : " + this.converter);
    }
}
```

```java
 // Adapts a ConverterFactory to a GenericConverter.
// org.springframework.core.convert.support.GenericConversionService.ConverterFactoryAdapter
private final class ConverterFactoryAdapter implements ConditionalGenericConverter {

    // 被包装的 ConverterFactory
    private final ConverterFactory<Object, Object> converterFactory;

    // 封装的类型对儿：源类型 -> 目类型
    private final ConvertiblePair typeInfo;

    public ConverterFactoryAdapter(ConverterFactory<?, ?> converterFactory, ConvertiblePair typeInfo) {
        this.converterFactory = (ConverterFactory<Object, Object>) converterFactory;
        this.typeInfo = typeInfo;
    }

    // 返回支持转换的类型对(多个)
    @Override
    public Set<ConvertiblePair> getConvertibleTypes() {
        return Collections.singleton(this.typeInfo);
    }

    // 保证所有实现 ConditionConverter 的转换器执行 matches 验证
    @Override
    public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {
        boolean matches = true;
        if (this.converterFactory instanceof ConditionalConverter) {
            matches = ((ConditionalConverter) this.converterFactory).matches(sourceType, targetType);
        }
        if (matches) {
            Converter<?, ?> converter = this.converterFactory.getConverter(targetType.getType());
            if (converter instanceof ConditionalConverter) {
                matches = ((ConditionalConverter) converter).matches(sourceType, targetType);
            }
        }
        return matches;
    }

    @Override
    @Nullable
    public Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {
        if (source == null) {
            // 处理 Null -> Optional
            return convertNullSource(sourceType, targetType);
        }
        // 调用包装的工厂方法创建转换器，并进行类型转换
        return this.converterFactory.getConverter(targetType.getObjectType()).convert(source);
    }

    @Override
    public String toString() {
        return (this.typeInfo + " : " + this.converterFactory);
    }
}
```

**`ConvertiblePair`** 封装了源数据类型和目标数据类型，并覆写了 `hashCode` 和 `equals` 方法，主要用做 `Map` 的 key。

```java
// Holder for a source-to-target class pair.
// org.springframework.core.convert.converter.GenericConverter.ConvertiblePair
final class ConvertiblePair {

    private final Class<?> sourceType;

    private final Class<?> targetType;

    // Create a new source-to-target pair.
    public ConvertiblePair(Class<?> sourceType, Class<?> targetType) {
        Assert.notNull(sourceType, "Source type must not be null");
        Assert.notNull(targetType, "Target type must not be null");
        this.sourceType = sourceType;
        this.targetType = targetType;
    }

    public Class<?> getSourceType() {
        return this.sourceType;
    }

    public Class<?> getTargetType() {
        return this.targetType;
    }

    @Override
    public boolean equals(@Nullable Object other) {
        if (this == other) {
            return true;
        }
        if (other == null || other.getClass() != ConvertiblePair.class) {
            return false;
        }
        ConvertiblePair otherPair = (ConvertiblePair) other;
        return (this.sourceType == otherPair.sourceType && this.targetType == otherPair.targetType);
    }

    @Override
    public int hashCode() {
        return (this.sourceType.hashCode() * 31 + this.targetType.hashCode());
    }

    @Override
    public String toString() {
        return (this.sourceType.getName() + " -> " + this.targetType.getName());
    }
}
```

`ConvertersForPair` 封装了指定 `ConvertiblePair` 对应的转换器列表。 注意每次添加转换器会调用 `addFirst`，在 `getConverter` 方法中会先从列表的第一个转换器验证，如果匹配直接返回而不会遍历之后的转换器。因为 Spring 默认会内置一些转换器，所以当添加自定义转换器时会添加到列表首位，即会覆盖默认转换器。

```java
// Manages converters registered with a specific ConvertiblePair.
// org.springframework.core.convert.support.GenericConversionService.ConvertersForPair
private static class ConvertersForPair {

    // 每个类型对儿可能对应多个转换器，因此使用列表存储
    private final LinkedList<GenericConverter> converters = new LinkedList<>();

    public void add(GenericConverter converter) {
        // 添加到列表首位
        this.converters.addFirst(converter);
    }

    // 获取 ConditionalConverter 时执行 matches 验证
    public GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {
        for (GenericConverter converter : this.converters) {
            // 如果不是 ConditionalConverter 则直接返回该 Converter，否则进行 matches 验证
            if (!(converter instanceof ConditionalGenericConverter) ||
                    ((ConditionalGenericConverter) converter).matches(sourceType, targetType)) {
                return converter;
            }
        }
        return null;
    }

    @Override
    public String toString() {
        return StringUtils.collectionToCommaDelimitedString(this.converters);
    }
}
```

## 注册转换器

`GenericConversionService` 实现了 `ConverterRegistry` 接口，提供了注册转换器的具体实现。

```java
// ConverterRegistry implementation
// org.springframework.core.convert.support.GenericConversionService

// 注册 Converter
@Override
public void addConverter(Converter<?, ?> converter) {
    // 获取类上的泛型信息
    ResolvableType[] typeInfo = getRequiredTypeInfo(converter.getClass(), Converter.class);
    if (typeInfo == null && converter instanceof DecoratingProxy) {
        typeInfo = getRequiredTypeInfo(((DecoratingProxy) converter).getDecoratedClass(), Converter.class);
    }
    if (typeInfo == null) {
        throw new IllegalArgumentException("Unable to determine source type <S> and target type <T> for your " +
                "Converter [" + converter.getClass().getName() + "]; does the class parameterize those types?");
    }
    // 使用适配器转换为 GenericConverter 并注册
    addConverter(new ConverterAdapter(converter, typeInfo[0], typeInfo[1]));
}

@Override
public <S, T> void addConverter(Class<S> sourceType, Class<T> targetType, Converter<? super S, ? extends T> converter) {
    addConverter(new ConverterAdapter(
            converter, ResolvableType.forClass(sourceType), ResolvableType.forClass(targetType)));
}

@Override
public void addConverter(GenericConverter converter) {
    // 将转换器注册到内部类 Converters
    this.converters.add(converter);
    // 每次添加需要清空缓存
    invalidateCache();
}

// 注册 ConverterFactory
@Override
public void addConverterFactory(ConverterFactory<?, ?> factory) {
    // 获取泛型信息
    ResolvableType[] typeInfo = getRequiredTypeInfo(factory.getClass(), ConverterFactory.class);
    // 判断是否是代理类，如果是代理类则获取被代理类上的泛型
    if (typeInfo == null && factory instanceof DecoratingProxy) {
        typeInfo = getRequiredTypeInfo(((DecoratingProxy) factory).getDecoratedClass(), ConverterFactory.class);
    }
    if (typeInfo == null) {
        throw new IllegalArgumentException("Unable to determine source type <S> and target type <T> for your " +
                "ConverterFactory [" + factory.getClass().getName() + "]; does the class parameterize those types?");
    }
    // 适配器转换并注册
    addConverter(new ConverterFactoryAdapter(factory,
            new ConvertiblePair(typeInfo[0].resolve(Object.class), typeInfo[1].resolve(Object.class))));
}

@Override
public void removeConvertible(Class<?> sourceType, Class<?> targetType) {
    this.converters.remove(sourceType, targetType);
    invalidateCache();
}
```

`GenericConversionService` 内部维护了一个 `Converters` 内部类对象。`Converters` 使用一个 `Map<ConvertiblePair, ConvertersForPair>` 来存储类型对儿和转换器之间的关系，注册的类型转换器全部存储在这个 Map。

```java
// org.springframework.core.convert.support.GenericConversionService.Converters
private static class Converters {

    // 用于保存 ConditionalConverter
    private final Set<GenericConverter> globalConverters = new LinkedHashSet<>();

    // 维护类型对(ConvertiblePair)与转换器(ConvertersForPair)之间的映射关系
    private final Map<ConvertiblePair, ConvertersForPair> converters = new LinkedHashMap<>(36);

    public void add(GenericConverter converter) {
        // 获取 converter 支持的类型转换对儿 
        Set<ConvertiblePair> convertibleTypes = converter.getConvertibleTypes();
        if (convertibleTypes == null) {
            Assert.state(converter instanceof ConditionalConverter,
                    "Only conditional converters may return null convertible types");
            this.globalConverters.add(converter);
        }
        else {
            for (ConvertiblePair convertiblePair : convertibleTypes) {
                // 建立 Map 映射关系并注册到 converters 对象
                ConvertersForPair convertersForPair = getMatchableConverters(convertiblePair);
                // 将 Converter 添加到列表首位
                convertersForPair.add(converter);
            }
        }
    }

    // 返回类型对儿对应的转换器封装对象：若存在则直接返回，否则先创建。
    private ConvertersForPair getMatchableConverters(ConvertiblePair convertiblePair) {
        ConvertersForPair convertersForPair = this.converters.get(convertiblePair);
        if (convertersForPair == null) {
            convertersForPair = new ConvertersForPair();
            this.converters.put(convertiblePair, convertersForPair);
        }
        return convertersForPair;
    }
}
```

## 查询转换器

`GenericConversionService` 实现了 `ConversionService` 接口，提供根据源数据类型和目标数据类型查找相应类型转换器的功能。

```java
// ConversionService implementation
// org.springframework.core.convert.support.GenericConversionService

@Override
public boolean canConvert(@Nullable Class<?> sourceType, Class<?> targetType) {
    Assert.notNull(targetType, "Target type to convert to cannot be null");
    return canConvert((sourceType != null ? TypeDescriptor.valueOf(sourceType) : null),
            TypeDescriptor.valueOf(targetType));
}

@Override
public boolean canConvert(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType) {
    Assert.notNull(targetType, "Target type to convert to cannot be null");
    if (sourceType == null) {
        return true;
    }
    // 如果能根据源类型和目标类型查询到转换器则表示支持转换
    GenericConverter converter = getConverter(sourceType, targetType);
    return (converter != null);
}

/**
 * Return whether conversion between the source type and the target type can be bypassed.
 * More precisely, this method will return true if objects of sourceType can be
 * converted to the target type by returning the source object unchanged.
 * @param sourceType context about the source type to convert from
 * (may be {@code null} if source is {@code null})
 * @param targetType context about the target type to convert to (required)
 * @return {@code true} if conversion can be bypassed; {@code false} otherwise
 * @throws IllegalArgumentException if targetType is {@code null}
 */
public boolean canBypassConvert(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType) {
    Assert.notNull(targetType, "Target type to convert to cannot be null");
    if (sourceType == null) {
        return true;
    }
    GenericConverter converter = getConverter(sourceType, targetType);
    return (converter == NO_OP_CONVERTER);
}
```

在 `getConverter` 方法中通过 `converters` 内部类对象查询 `Map` 中维护的类型转换器，并将结果缓存起来。方法中的 `NO_OP_CONVERTER` 和 `NO_MATCH` 均为 `GenericConversionService.NoOpConverter` 类型的常量对象，仅作为匹配标识并不具备类型转换功能。

```java
// org.springframework.core.convert.support.GenericConversionService#getConverter

/**
 * Hook method to lookup the converter for a given sourceType/targetType pair.
 * First queries this ConversionService's converter cache.
 * On a cache miss, then performs an exhaustive search for a matching converter.
 * If no converter matches, returns the default converter.
 * @return the generic converter that will perform the conversion,
 * or {@code null} if no suitable converter was found
 */
protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {
    ConverterCacheKey key = new ConverterCacheKey(sourceType, targetType);
    // 先从缓存获取
    GenericConverter converter = this.converterCache.get(key);
    if (converter != null) {
        return (converter != NO_MATCH ? converter : null);
    }
    // 调用内部类对象查询转换器
    converter = this.converters.find(sourceType, targetType);

    // 如果查询结果为空且 targetType 是 sourceType 的子类型，
    // 则返回 NoOpConverter，否则返回 Null
    if (converter == null) {
        converter = getDefaultConverter(sourceType, targetType);
    }
    // 将查询结果缓存提升查询性能
    if (converter != null) {
        this.converterCache.put(key, converter);
        return converter;
    }
    // 如果最终查询结果为空则缓存为没有匹配
    this.converterCache.put(key, NO_MATCH);
    return null;
}

/**
 * Return the default converter if no converter is found for the given sourceType/targetType pair.
 * Returns a NO_OP Converter if the source type is assignable to the target type.
 * Returns {@code null} otherwise, indicating no suitable converter could be found.
 * @return the default generic converter that will perform the conversion
 */
protected GenericConverter getDefaultConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {
    return (sourceType.isAssignableTo(targetType) ? NO_OP_CONVERTER : null);
}
```

内部类 `Converters` 的 `find` 方法查询匹配的转换器时会先根据源类型和目标类型查询，如果没有再遍历父类和接口查询转换器。

```java
// org.springframework.core.convert.support.GenericConversionService.Converters#find

/**
 * Find a {@link GenericConverter} given a source and target type.
 * This method will attempt to match all possible converters by working
 * through the class and interface hierarchy of the types.
 * @return a matching {@link GenericConverter}, or {@code null} if none found
 */
public GenericConverter find(TypeDescriptor sourceType, TypeDescriptor targetType) {
    // Search the full type hierarchy
    // 获取源数据类型和目标数据类型的继承线上的类和接口
    // 比如 Integer 获取的 candidates 列表为： [class java.lang.Integer, class java.lang.Number, 
    // interface java.lang.Comparable, interface java.io.Serializable, class java.lang.Object]
    List<Class<?>> sourceCandidates = getClassHierarchy(sourceType.getType());
    List<Class<?>> targetCandidates = getClassHierarchy(targetType.getType());
    // 从两个列表的所有类型两两组合开始查找匹配的转换器，先从当前类型开始查找匹配的转换器
    // 如果不匹配则逐步向上直到父类和接口，即最坏情况的类型转换会回退到 Objetc -> Object
    for (Class<?> sourceCandidate : sourceCandidates) {
        for (Class<?> targetCandidate : targetCandidates) {
            ConvertiblePair convertiblePair = new ConvertiblePair(sourceCandidate, targetCandidate);
            GenericConverter converter = getRegisteredConverter(sourceType, targetType, convertiblePair);
            if (converter != null) {
                return converter;
            }
        }
    }
    return null;
}

private GenericConverter getRegisteredConverter(TypeDescriptor sourceType,
        TypeDescriptor targetType, ConvertiblePair convertiblePair) {

    // Check specifically registered converters
    // 保存类型对儿信息的 Converter 均从此处返回
    ConvertersForPair convertersForPair = this.converters.get(convertiblePair);
    if (convertersForPair != null) {
        // getConverter 内部会对实现 ConditionalConverter 接口的 Converter 执行 matches 验证
        GenericConverter converter = convertersForPair.getConverter(sourceType, targetType);
        if (converter != null) {
            return converter;
        }
    }
    // Check ConditionalConverters for a dynamic match
    // 没有保存类型对儿的 ConditionalConverter 会注册到 globalConverters
    for (GenericConverter globalConverter : this.globalConverters) {
        if (((ConditionalConverter) globalConverter).matches(sourceType, targetType)) {
            return globalConverter;
        }
    }
    return null;
}

// org.springframework.core.convert.support.GenericConversionService.ConvertersForPair#getConverter
// 获取 ConditionalConverter 时执行 matches 验证
public GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {
    for (GenericConverter converter : this.converters) {
        // 如果不是 ConditionalConverter 则直接返回该 Converter，否则进行 matches 验证
        if (!(converter instanceof ConditionalGenericConverter) ||
                ((ConditionalGenericConverter) converter).matches(sourceType, targetType)) {
            // 注意这里从列表首位开始遍历，一旦匹配即刻返回，排在后面的转换器就无法执行。
            return converter;
        }
    }
    return null;
}

```

## 类型转换

`GenericConversionService` 实现了 `ConversionService` 接口，提供了类型转换的具体实现，集中为所有 `Converter、GenericConverter、ConverterFactory` 的类型转换功能提供了一个入口，在这里体现了策略模式，`GenericConversionService` 相当于是策略模式中的 `Context` 用于选择策略。

```java
// ConversionService implementation
// org.springframework.core.convert.support.GenericConversionService


@Override
public <T> T convert(@Nullable Object source, Class<T> targetType) {
    Assert.notNull(targetType, "Target type to convert to cannot be null");
    return (T) convert(source, TypeDescriptor.forObject(source), TypeDescriptor.valueOf(targetType));
}

/**
 * Convenience operation for converting a source object to the specified targetType,
 * where the target type is a descriptor that provides additional conversion context.
 * Simply delegates to {@link #convert(Object, TypeDescriptor, TypeDescriptor)} and
 * encapsulates the construction of the source type descriptor using
 * @throws ConversionException if a conversion exception occurred
 * @throws IllegalArgumentException if targetType is {@code null},
 * or sourceType is {@code null} but source is not {@code null}
 */
public Object convert(@Nullable Object source, TypeDescriptor targetType) {
    return convert(source, TypeDescriptor.forObject(source), targetType);
}

@Override
public Object convert(@Nullable Object source, @Nullable TypeDescriptor sourceType, TypeDescriptor targetType) {
    Assert.notNull(targetType, "Target type to convert to cannot be null");
    if (sourceType == null) {
        Assert.isTrue(source == null, "Source must be [null] if source type == [null]");
        return handleResult(null, targetType, convertNullSource(null, targetType));
    }
    if (source != null && !sourceType.getObjectType().isInstance(source)) {
        throw new IllegalArgumentException("Source to convert from must be an instance of [" +
                sourceType + "]; instead it was a [" + source.getClass().getName() + "]");
    }
    // 从缓存中获取转换器，如果缓存 Miss 则执行具体的查询过程并缓存
    GenericConverter converter = getConverter(sourceType, targetType);
    if (converter != null) {
        // 委派工具类执行 Converter 的转换方法
        Object result = ConversionUtils.invokeConverter(converter, source, sourceType, targetType);
        // 转换结果不为为空直接返回，否则若结果为空且目标类型是原始类型则抛出异常
        return handleResult(sourceType, targetType, result);
    }
    // 没有获取到 Converter 时，处理 sourceObject 或 sourceType 为空的情况
    return handleConverterNotFound(source, sourceType, targetType);
}

// org.springframework.core.convert.support.GenericConversionService#handleResult
private Object handleResult(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType, @Nullable Object result) {
    if (result == null) {
        assertNotPrimitiveTargetType(sourceType, targetType);
    }
    return result;
}

private void assertNotPrimitiveTargetType(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType) {
    if (targetType.isPrimitive()) {
        throw new ConversionFailedException(sourceType, targetType, null,
                new IllegalArgumentException("A null value cannot be assigned to a primitive type"));
    }
}

private Object handleConverterNotFound(
        @Nullable Object source, @Nullable TypeDescriptor sourceType, TypeDescriptor targetType) {

    if (source == null) {
        assertNotPrimitiveTargetType(sourceType, targetType);
        return null;
    }
    if ((sourceType == null || sourceType.isAssignableTo(targetType)) &&
            targetType.getObjectType().isInstance(source)) {
        return source;
    }
    throw new ConverterNotFoundException(sourceType, targetType);
}
```

## ConversionServiceFactoryBean

Spring 使用 `ConversionServiceFactoryBean` 集成了 `ConversionService` 的功能，下面来看 `ConversionServiceFactoryBean` 的具体实现。

```java
/**
 * A factory providing convenient access to a ConversionService configured with
 * converters appropriate for most environments. Set the
 * {@link #setConverters "converters"} property to supplement the default converters.
 *
 * This implementation creates a {@link DefaultConversionService}.
 * Subclasses may override {@link #createConversionService()} in order to return
 * a {@link GenericConversionService} instance of their choosing.
 *
 * Like all {@code FactoryBean} implementations, this class is suitable for
 * use when configuring a Spring application context using Spring {@code <beans>}
 * XML. When configuring the container with
 * {@link org.springframework.context.annotation.Configuration @Configuration}
 * classes, simply instantiate, configure and return the appropriate
 * {@code ConversionService} object from a {@link
 * org.springframework.context.annotation.Bean @Bean} method.
 */
// org.springframework.context.support.ConversionServiceFactoryBean
public class ConversionServiceFactoryBean implements FactoryBean<ConversionService>, InitializingBean {

    @Nullable
    private Set<?> converters;

    @Nullable
    private GenericConversionService conversionService;

    /**
     * Configure the set of custom converter objects that should be added:
     * implementing {@link org.springframework.core.convert.converter.Converter},
     * {@link org.springframework.core.convert.converter.ConverterFactory},
     * or {@link org.springframework.core.convert.converter.GenericConverter}.
     */
    public void setConverters(Set<?> converters) {
        this.converters = converters;
    }

    @Override
    public void afterPropertiesSet() {
        this.conversionService = createConversionService();
        // 将自定义类型转换器注册到上面创建的 ConversionService
        ConversionServiceFactory.registerConverters(this.converters, this.conversionService);
    }

    /**
     * Create the ConversionService instance returned by this factory bean.
     * Creates a simple {@link GenericConversionService} instance by default.
     * Subclasses may override to customize the ConversionService instance that
     * gets created.
     */
    protected GenericConversionService createConversionService() {
        return new DefaultConversionService();
    }

    // implementing FactoryBean

    @Override
    public ConversionService getObject() {
        // 由于实现了 FactoryBean 接口，所以从容器获取该 Bean 时实际会返回 conversionService 对象
        return this.conversionService;
    }

    @Override
    public Class<? extends ConversionService> getObjectType() {
        return GenericConversionService.class;
    }

    @Override
    public boolean isSingleton() {
        return true;
    }

}
```

从源码中可以看出 `ConversionServiceFactoryBean` 实现了 `FactoryBean` 和 `InitializingBean` 接口，在初始化完成后创建了一个 `DefaultConversionService` 对象，然后调用 `ConversionServiceFactory` 的 `registerConverters` 注册自定义的类型转换器。由于该类实现了 FactoryBean 接口，所以从容器获取该 Bean 时实际会返回创建的 `DefaultConversionService` 对象。

```java
/**
 * Register the given Converter objects with the given target ConverterRegistry.
 * @param converters the converter objects: implementing {@link Converter},
 * {@link ConverterFactory}, or {@link GenericConverter}
 * @param registry the target registry
 */
// org.springframework.core.convert.support.ConversionServiceFactory#registerConverters
public static void registerConverters(@Nullable Set<?> converters, ConverterRegistry registry) {
    if (converters != null) {
        for (Object converter : converters) {
            // 调用父类 GenericConversionService 的注册方法
            if (converter instanceof GenericConverter) {
                registry.addConverter((GenericConverter) converter);
            }
            else if (converter instanceof Converter<?, ?>) {
                registry.addConverter((Converter<?, ?>) converter);
            }
            else if (converter instanceof ConverterFactory<?, ?>) {
                registry.addConverterFactory((ConverterFactory<?, ?>) converter);
            }
            else {
                throw new IllegalArgumentException("Each converter object must implement one of the " +
                        "Converter, ConverterFactory, or GenericConverter interfaces");
            }
        }
    }
}
```

`DefaultConversionService` 继承了 `GenericConversionService` 所以注册转换器时实际调用的是父类的方法，前文已作分析自此不再赘述。那么 `DefaultConversionService` 又做了哪些扩展呢?

```java
/**
 * A specialization of {@link GenericConversionService} configured by default
 * with converters appropriate for most environments.
 * 
 * GenericConversionService的专用实现，默认配置了适用于大多数环境的转换器。
 * 
 * Designed for direct instantiation but also exposes the static
 * {@link #addDefaultConverters(ConverterRegistry)} utility method for ad-hoc
 * use against any {@code ConverterRegistry} instance.
 * 
 * 专为直接实例化而设计，但也公开了静态 addDefaultConverters 方法，以便针对任何 ConverterRegistry 的临时使用。
 * 
 */
// org.springframework.core.convert.support.DefaultConversionService
public class DefaultConversionService extends GenericConversionService {

    @Nullable
    private static volatile DefaultConversionService sharedInstance;

    // Create a new {@code DefaultConversionService} with the set of
    public DefaultConversionService() {
        addDefaultConverters(this);
    }

    /**
     * Return a shared default {@code ConversionService} instance,
     * lazily building it once needed.
     * NOTE: We highly recommend constructing individual
     * {@code ConversionService} instances for customization purposes.
     * This accessor is only meant as a fallback for code paths which
     * need simple type coercion but cannot access a longer-lived
     * {@code ConversionService} instance any other way.
     * 
     * 返回一个共享的默认转换服务实例，在需要时懒惰地构建它。
     * 
     * 注意：我们强烈建议出于自定义目的构造单个转换服务实例。
     * 此方法仅用于回退需要简单类型强制但无法以任何其他方式访问生存期较长的 
     * ConversionService 实例的代码路径。
     * 
     */
    public static ConversionService getSharedInstance() {
        DefaultConversionService cs = sharedInstance;
        if (cs == null) {
            synchronized (DefaultConversionService.class) {
                cs = sharedInstance;
                if (cs == null) {
                    cs = new DefaultConversionService();
                    sharedInstance = cs;
                }
            }
        }
        return cs;
    }

    /**
     * Add converters appropriate for most environments.
     * 
     * 添加适用于大多数环境的内置转换器。
     * 
     * @param converterRegistry the registry of converters to add to
     * (must also be castable to ConversionService, e.g. being a {@link ConfigurableConversionService})
     * @throws ClassCastException if the given ConverterRegistry could not be cast to a ConversionService
     */
    public static void addDefaultConverters(ConverterRegistry converterRegistry) {
        addScalarConverters(converterRegistry);
        // Add common collection converters.
        addCollectionConverters(converterRegistry);

        converterRegistry.addConverter(new ByteBufferConverter((ConversionService) converterRegistry));
        converterRegistry.addConverter(new StringToTimeZoneConverter());
        converterRegistry.addConverter(new ZoneIdToTimeZoneConverter());
        converterRegistry.addConverter(new ZonedDateTimeToCalendarConverter());

        converterRegistry.addConverter(new ObjectToObjectConverter());
        converterRegistry.addConverter(new IdToEntityConverter((ConversionService) converterRegistry));
        converterRegistry.addConverter(new FallbackObjectToStringConverter());
        converterRegistry.addConverter(new ObjectToOptionalConverter((ConversionService) converterRegistry));
    }

    // 省略 addScalarConverters、addCollectionConverters 源码
}
```

看源码发现 `DefaultConversionService` 提供了普通创建和单例创建两种模式。在 `ConversionServiceFactoryBean` 中使用的是 `new`，而且源码注释强烈建议如果是出于自定义目的则应该使用 `new` 构造单个转换服务实例。获取单例的方式仅用于回退需要简单类型强制但无法以任何其他方式访问生存期较长的 `ConversionService` 实例的替代方案。

## 简单应用

自定义`日期` -> `字符串`转换器实现 `LocalDateTime` 到 `String` 的转换。

```java
public class LocalDateTime2StringConverter implements Converter<LocalDateTime, String> {
    @Override
    public String convert(LocalDateTime source) {
        if(source == null){
            return "";
        }
        return source.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
    }
}
```

自定义 `String` -> `Enum` 转换器，针对枚举类中有 `code()` 方法的，使用 `code` 转换，否则使用 `name` 转换。

```java
@SuppressWarnings("all")
public class String2EnumConverterFactory implements ConverterFactory<String, Enum>, ConditionalConverter {

    private static final String METHOD_NAME = "code";

    @Override
    public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {
        // 只处理 String -> Enum
        return (sourceType != null && String.class.isAssignableFrom(sourceType.getType()) &&
                targetType != null && targetType.getType().isEnum());
    }

    @Override
    public <T extends Enum> Converter<String, T> getConverter(Class<T> targetType) {
        return new String2EnumConverter<>(targetType);
    }

    private static class String2EnumConverter<T extends Enum> implements Converter<String, T> {

        private final Class<T> targetType;

        public String2EnumConverter(Class<T> targetType) {
            this.targetType = targetType;
        }

        @Override
        public T convert(String source) {
            AtomicReference<T> result = new AtomicReference<>();
            if(source != null && !source.isEmpty()){
                final String source2use = source.trim();
                Method getCode = null;
                try {
                    getCode = targetType.getMethod(METHOD_NAME);
                } catch (NoSuchMethodException e) {
                    // fallback to by name if no code method
                }
                final Method code = getCode;
                T[] enumCosts = targetType.getEnumConstants();
                Arrays.stream(enumCosts).forEach(e -> {
                    try {
                        // 查找 code 匹配 或 name 匹配的枚举
                        if((code != null && source2use.equals(code.invoke(e)))
                                || e.name().equals(source2use)){
                            result.set(e);
                            return;
                        }
                    } catch (IllegalAccessException ex) {
                        ex.printStackTrace();
                    } catch (InvocationTargetException ex) {
                        ex.printStackTrace();
                    }
                });
            }
            return result.get();
        }
    }
}
```

**测试用例**

```java
public enum Color {

    RED("01", "红色"), GREEN("02", "绿色"), YELLOW("03", "黄色");

    final String code;

    final String detail;

    Color(String code, String detail){
        this.code = code;
        this.detail = detail;
    }

    public String code() {
        return code;
    }

    public String detail() {
        return detail;
    }
}
```

```java
@Test
public void test01(){
    DefaultConversionService conversionService = new DefaultConversionService();
    conversionService.addConverterFactory(new String2EnumConverterFactory());
    conversionService.addConverter(new LocalDateTime2StringConverter());

    String now = conversionService.convert(LocalDateTime.now(), String.class);
    System.out.println(now);

    String[] colors = {"01", "GREEN", "03", "hello"};
    Arrays.stream(colors).forEach(source -> {
        Enum<Color> color = conversionService.convert(source, Color.class);
        System.out.print(color + ", ");
    });
}
```

**控制台输出**

```console
2023-08-30 23:56:26
RED, GREEN, YELLOW, null, 
```

## 案例分析

### ObjectToOptionalConverter

`Object` 转换 `Optional` 使用了在 `DefaultConversionService` 中注册的内置转换器 `ObjectToOptionalConverter`。因为 `Optional` 是一个包装类型，所以转换时要将 `sourceObject` 转换为 `Optional` 包装的内部类型。`注意`：需要依赖 `Optional` 中的泛型类型进行转换。

```java
/**
 * Convert an Object to {@code java.util.Optional<T>} if necessary using the
 * {@code ConversionService} to convert the source Object to the generic type
 * of Optional when known.
 */
// org.springframework.core.convert.support.ObjectToOptionalConverter
final class ObjectToOptionalConverter implements ConditionalGenericConverter {

    private final ConversionService conversionService;

    public ObjectToOptionalConverter(ConversionService conversionService) {
        this.conversionService = conversionService;
    }

    @Override
    public Set<ConvertiblePair> getConvertibleTypes() {
        Set<ConvertiblePair> convertibleTypes = new LinkedHashSet<>(4);
        convertibleTypes.add(new ConvertiblePair(Collection.class, Optional.class));
        convertibleTypes.add(new ConvertiblePair(Object[].class, Optional.class));
        convertibleTypes.add(new ConvertiblePair(Object.class, Optional.class));
        return convertibleTypes;
    }

    @Override
    public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {
        // 获取 Optional 的泛型类型进行匹配查找，例如获取 Optional<String> 的 String 泛型
        if (targetType.getResolvableType().hasGenerics()) {
            // 判断源类型能否转换到泛型类型
            return this.conversionService.canConvert(sourceType, new GenericTypeDescriptor(targetType));
        }
        // Optional 没有声明泛型：直接使用 Optional 包装转换
        // 实测即使没有声明泛型也不走 else 流程，而是走 if 流程
        else {
            return true;
        }
    }

    @Override
    public Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {
        if (source == null) {
            return Optional.empty();
        }
        else if (source instanceof Optional) {
            return source;
        }
        // Optional 声明了泛型类型则需要进行转换
        else if (targetType.getResolvableType().hasGenerics()) {
            // 先将 source 转换为 Optional 的泛型类型
            Object target = this.conversionService.convert(source, sourceType, new GenericTypeDescriptor(targetType));
            if (target == null || (target.getClass().isArray() && Array.getLength(target) == 0) ||
                        (target instanceof Collection && ((Collection<?>) target).isEmpty())) {
                return Optional.empty();
            }
            // 使用 Optional 封装已转换的值
            return Optional.of(target);
        }
        // Optional 没有声明泛型类型则直接进行包装
        else {
            return Optional.of(source);
        }
    }


    @SuppressWarnings("serial")
    private static class GenericTypeDescriptor extends TypeDescriptor {

        public GenericTypeDescriptor(TypeDescriptor typeDescriptor) {
            super(typeDescriptor.getResolvableType().getGeneric(), null, typeDescriptor.getAnnotations());
        }
    }

}
```

注意如果传入的 `targetType` 是一个 `Optional` 的 `raw type` 也就是没有指定泛型，那么通过类型对 `Object -> Optional` 确实会调用到 `ObjectToOptionalConverter` 这个转换器，但是在 `matches` 方法中 `if (targetType.getResolvableType().hasGenerics())` 判断为 `true`，即也是获取到了泛型，只不过这里的泛型变为 `?` (实际类型是 `Object`)，虽然进入 `if` 分支后在 `canConvert` 方法中会返回 `true` 最终达到匹配，但过程有点曲折；本意是将源对象转换到 `Optional` 并不需指定泛型，即只需走 `matches` 和 `convert` 方法的 `else` 分支；个人认为这里是个 `bug`，在 `matches` 应该判断泛型不是 `Object` 才进入 `if` 分支。

那么在 `canConvert` 方法中到底做了哪些判断才最终匹配? 在这个方法中会调用 `GenericConversionService#getConverter` 查找从源类型转换到泛型的转换器，比如 `Integer` -> `Optional`(无泛型)，最终会查找：`Integer` -> `Object`、`Number` -> `Object`、`Comparable` -> `Object`、`Serializable` -> `Object`、`Object`-> `Object` 这些转换器，后面的类型都是 `Integer` 的父类或接口。

`debg` 发现只在 `Object` -> `Object` 类型对儿找到了两个对应的 `Converter`，分别是 `IdToEntityConverter` 和 `ObjectToObjectConverter`，但是 `matches` 方法都没有匹配；这两个转换器都是根据工厂方法进行匹配的，目标类型必须存在相应的工厂方法才能转换（下文会说明），但是这里的 `Optional` 的泛型为 `Object`，即目标类型是 `Object` 自然不会存在那些乱七八糟的工厂方法。 

前面仅有的两个 `Converter` 无法匹配，这时会进行简单判断：如果源类型是目标类型或其子类型，则无需进行转换（相当于子类型转换到父类型）会返回一个 `NO_OP_CONVERTER`，转换时直接返回源对象；如果上述类型判断不成立，这时才确定无法获取相应的转换器并返回 `Null`，返回到 `canConvert` 方法就是返回 `false`。

```java
// org.springframework.core.convert.support.GenericConversionService#getConverter
// 没有找到匹配的 Converter，下面进行类型判断
converter = this.converters.find(sourceType, targetType);
if (converter == null) {
    converter = getDefaultConverter(sourceType, targetType);
}
protected GenericConverter getDefaultConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {
    // 简单判断源类型是否是目标类型或其子类型
    return (sourceType.isAssignableTo(targetType) ? NO_OP_CONVERTER : null);
}
```

那么在上述例子中 `integer` -> `Object` 就会匹配到 `NO_OP_CONVERTER` 并加入缓存，这时返回到 `ObjectToOptionalConverter` 的 `matches` 方法的 `if` 分支就会返回 `true`，外部调用 `Integer` -> `Optional`(无泛型) 的转换方法返回的转换器就是 `ObjectToOptionalConverter`并加入缓存，这里注意保存的类型对儿是 `Integer` -> `Optional<?>`。然后转换时先将源对象转换到 Optional 泛型类型，本例使用的转换器是 `NO_OP_CONVERTER`，最后使用 `Optional.of` 包装完成转换。

**测试用例**

```java
@Test
public void test02() {

    // 获取的泛型是 '?'
    // Optional op = conversionService.convert(125, Optional.class);

    // 获取的泛型是 '?'
    // Optional op = conversionService.convert(125, Optional.of(10).getClass());

    // 编译不通过
    // Optional op = conversionService.convert(125, Optional<Integer>.class);

    // 获取参数化类型：TypeHolder<Optional<String>>
    ParameterizedType p = (ParameterizedType) new TypeHolder<Optional<String>>(){}.getClass().getGenericSuperclass();
    // 获取类型参数：Optional<String> 然后转换：Integer -> Opptional<String>
    Optional op = (Optional) conversionService.convert(125, new ParamTypeDescriptor(p.getActualTypeArguments()[0]));
    System.out.println(op.get() + " is String? " + (op.get() instanceof String));
    // 输出：125 is String? true
}

static class TypeHolder<T> {}

// org.springframework.core.convert.TypeDescriptor
static class ParamTypeDescriptor extends TypeDescriptor {

    public ParamTypeDescriptor(Type type) {
        super(ResolvableType.forType(type), null, null);
    }
}
```

在测试时发现如果直接使用 `ConversionService` 的转换方法，无法直接传入泛型类型作为 `targetType`，只能使用无泛型的 `Optional`；如果要实现将 `Integer` 转换为 `Optional<String>` ，即先将源类型 `Integer` 转换为 `String` 再包装为 `Optional`，则需要用到支持泛型的 `TypeDescriptor` 作为目标类型参数，这是一个 Spring 的类型转换信息类。关键是如何获取到泛型类型? 

这里借鉴了谷歌 `Gson` 包的 `TypeToken`，由于 Java 在运行时会擦除泛型信息，只有在`类、字段、方法`定义的泛型会被保留，因此可以使用一个匿名内部类保存需要的泛型信息，随后再通过反射来获取。测试用例中定义了一个泛型类 `TypeHolder`，然后通过 `new TypeHolder<Optional<Integer>>(){}` 的形式获取匿名类对象，在通过反射得到泛型类型，就可以获取该匿名类型持有的泛型信息了。

如果是在 `Bean` 中定义的属性为 `Optional` 类型，则一定要声明泛型，否则只会转换为源对象的 `Optional` 包装类型。

### ObjectToObjectConverter

该转换器匹配类型为 `Object` -> `Object`，任意两个类型的转换最坏情况都会回退到 `ObjectToObjectConverter`进行匹配（参考源码：`GenericConversionService.Converters#find`），这时还要继续判断 `matches` 方法返回 `true`才会使用这个转换器进行转换。

```java
// org.springframework.core.convert.support.ObjectToObjectConverter#matches
public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {
    // 判断源类型不等于目标类型并且存在转换的工厂方法时 返回 true
    return (sourceType.getType() != targetType.getType() &&
            hasConversionMethodOrConstructor(targetType.getType(), sourceType.getType()));
}

static boolean hasConversionMethodOrConstructor(Class<?> targetClass, Class<?> sourceClass) {
    return (getValidatedMember(targetClass, sourceClass) != null);
}

private static Member getValidatedMember(Class<?> targetClass, Class<?> sourceClass) {
    // 先从缓存获取转换目标类型的工厂方法
    Member member = conversionMemberCache.get(targetClass);
    // 判断工厂方法的声明类型或参数类型是否与源类型匹配
    if (isApplicable(member, sourceClass)) {
        return member;
    }
    // 从源类型中获取转换到目标类型的工厂方法：toXXX
    member = determineToMethod(targetClass, sourceClass);
    if (member == null) {
        // 从目标类型中获取源类型转换到目标类型的工厂方法：valueOf(s)、of(s)、from(s)
        member = determineFactoryMethod(targetClass, sourceClass);
        if (member == null) {
            // 从目标类型中获取参数类型为源类型的构造方法：public Target(source)
            member = determineFactoryConstructor(targetClass, sourceClass);
            if (member == null) {
                return null;
            }
        }
    }
    // 存入缓存
    conversionMemberCache.put(targetClass, member);
    return member;
}

private static Method determineToMethod(Class<?> targetClass, Class<?> sourceClass) {
    // 不接收源类型或目标类型为 String 的情况
    if (String.class == targetClass || String.class == sourceClass) {
        // Do not accept a toString() method or any to methods on String itself
        return null;
    }
    // 从源类型获取一个 public 非静态的无参的 toXXX 方法，返回值必须与目标类型匹配
    Method method = ClassUtils.getMethodIfAvailable(sourceClass, "to" + targetClass.getSimpleName());
    return (method != null && !Modifier.isStatic(method.getModifiers()) &&
            ClassUtils.isAssignable(targetClass, method.getReturnType()) ? method : null);
}

private static Method determineFactoryMethod(Class<?> targetClass, Class<?> sourceClass) {
    // 不接收目标类型为 String 的情况
    if (String.class == targetClass) {
        // Do not accept the String.valueOf(Object) method
        return null;
    }

    // 获取参数类型为源类型的静态方法 valueOf、of、from 三者按顺序取其一
    Method method = ClassUtils.getStaticMethod(targetClass, "valueOf", sourceClass);
    if (method == null) {
        method = ClassUtils.getStaticMethod(targetClass, "of", sourceClass);
        if (method == null) {
            method = ClassUtils.getStaticMethod(targetClass, "from", sourceClass);
        }
    }
    return method;
}

private static Constructor<?> determineFactoryConstructor(Class<?> targetClass, Class<?> sourceClass) {
    // 获取参数类型为源类型的目标类型的 public 构造函数
    return ClassUtils.getConstructorIfAvailable(targetClass, sourceClass);
}
```

分析源码可知，`matches` 判断源类型与目标类型是否匹配需要两个条件：

1) 源类型不等于目标类型；

2) 存在源类型转换为目标类型的工厂方法。

在 `getValidatedMember` 方法中可获取三种工厂方法，只要满足其中一个即可，下面以源类型 `Pookie` 目标类型 `Color` 为例说明：

+ 1、**源类型**中必须存在一个 `public`、`无参的`、`非静态` 方法，且方法名必须为 `toXXX`，返回值必须与目标类型匹配，方法名 `XXX` 代表的是目标类型的 `simpleName`。例如 `Pookie` -> `Color`，则 `Pookie` 定义的方法为 `public Color toColor()`。
    - 该方式需要非静态方法是因为转换时存在源对象，这时只需反射调用源对象的工厂方法进行转换。
    - 注意：该方式不支持源类型或目标类型为 `String` 的情况，即如果源类型是 `String` 不会返回它的 `toXXX` 方法；如果目标类型是 `String` 则不会返回源类型的 `toString` 方法。

+ 2、**目标类型**中必须存在一个 `public`、`参数个数为1`、`静态` 方法，且方法名必须为 `valueOf` 或 `of` 或 `from` 按顺序取其一，方法参数类型必须与源类型匹配。例如 `Pookie` -> `Color`，则 `Color` 定义的方法为 `public static Color of(Pookie)`
    - 该方式需要静态方法是因为转换时不存在 `target` 对象，而反射调用静态方法恰好无需 `target` 对象即可运行。
    - 注意：该方式不支持目标类型为 `String` 的情况，即如果目标类型是 `String` 不会返回 `String.valueOf(Object)` 方法；并且**该方式并没有校验方法的返回值类型是否与目标类型匹配**，所以使用不当容易发生类型转换异常 `ClassCastException`。

+ 3、**目标类型**中必须存在一个 `public`、`参数个数为1` 构造方法，且方法参数类型必须与源类型匹配。例如 `Pookie` -> `Color`，则 `Color` 定义的构造方法为 `public Color(Pookie)`。

以上三种工厂方法**按照顺序进行匹配**，只要匹配就会 `return` 因此会忽略后面可能匹配的工厂方法。最后 `ObjectToObjectConverter` 的类型转换过程其实就是反射调用工厂方法的过程，在此不作分析。

### IdToEntityConverter

`IdToEntityConverter` 与 `ObjectToObjectConverter` 的匹配类型一致均为 `Object` -> `Object`，但是**前者的优先级要比后者高**，原因是两者在 `DefaultConversionService#addDefaultConverters` 中的初始化顺序不同；又因为二者的匹配类型相同，所以这两个转换器都会保存在 `ConvertersForPair` 的 `LinkedList` 列表中，但是在添加时使用的是 `addFirst` 导致后加入的比先加入的优先级高。

```java
//org.springframework.core.convert.support.GenericConversionService.ConvertersForPair#add
public void add(GenericConverter converter) {
    this.converters.addFirst(converter);
}
```

`IdToEntityConverter` 能够实现从实体 ID 转换为实体对象，相当于根据 ID 从数据库中返回一条记录，但是这需要实体类中定义一个工厂方法用于将 ID 转换为实体对象。

```java
// org.springframework.core.convert.support.IdToEntityConverter#matches
public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {
    // 查找目标类型的转换工厂方法：findXXX
    Method finder = getFinder(targetType.getType());
    // finder 不为空并且源类型可以转换为工厂方法的参数类型
    return (finder != null &&
            this.conversionService.canConvert(sourceType, TypeDescriptor.valueOf(finder.getParameterTypes()[0])));
}

private Method getFinder(Class<?> entityClass) {
    String finderMethod = "find" + getEntityName(entityClass);
    Method[] methods;
    boolean localOnlyFiltered;
    try {
        // 获取所有在实体类中声明的方法(不包含父类方法)
        methods = entityClass.getDeclaredMethods();
        localOnlyFiltered = true;
    }
    catch (SecurityException ex) {
        // Not allowed to access non-public methods...
        // Fallback: check locally declared public methods only.
        // 获取实体类的所有 public 方法(包含父类方法)
        methods = entityClass.getMethods();
        localOnlyFiltered = false;
    }
    for (Method method : methods) {
        // 校验方法为静态、方法名称为findXXX、方法参数个数为1、方法返回值类型为该实体类型，
        // 最后判断如果获取的方法不是实体类声明的，还需要判断该方法所在类是否与实体类一致
        if (Modifier.isStatic(method.getModifiers()) && method.getName().equals(finderMethod) &&
                method.getParameterCount() == 1 && method.getReturnType().equals(entityClass) &&
                (localOnlyFiltered || method.getDeclaringClass().equals(entityClass))) {
            return method;
        }
    }
    return null;
}

// 获取实体类的简单类型名
private String getEntityName(Class<?> entityClass) {
    String shortName = ClassUtils.getShortName(entityClass);
    int lastDot = shortName.lastIndexOf('.');
    if (lastDot != -1) {
        return shortName.substring(lastDot + 1);
    }
    else {
        return shortName;
    }
}
```

分析源码可知，在 `matches` 方法中判断源类型与目标类型是否匹配同样需要两个条件：

1) 实体类型 (目标类型) 存在转换 ID 的工厂方法；

2) ID 类型 (源类型) 可以转换为工厂方法的参数类型。

`getFinder` 方法中获取的工厂方法必须满足：`public`、`static`、`参数个数为1`，且方法名必须为 `findXXX`、方法返回值类型必须与实体类型相同。其中 `XXX` 代表的是实体类型的 `simpleName`。例如 `Integer` -> `Pookie`，则 `Pookie` 定义的方法为 `public static Pookie findPookie(Integer)`。需要注意的是，工厂方法只能声明在该实体类中而不能在父类或接口，否则不会匹配这个工厂方法。根据源码非 `public` 的工厂方法也会匹配，但是在执行时会抛出 `IllegalStateException` 异常，原因是包外的类没有权限执行，需要设置 `m.setAccessible(true)`，但是源码中并没有这么做，因此这里还要加上 `public` 这个限制。

```java
// org.springframework.core.convert.support.IdToEntityConverter#convert
public Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {
    if (source == null) {
        return null;
    }
    // 获取工厂方法 findXXX
    Method finder = getFinder(targetType.getType());
    Assert.state(finder != null, "No finder method");
    // 将源ID对象转换为工厂方法的参数类型
    Object id = this.conversionService.convert(
            source, sourceType, TypeDescriptor.valueOf(finder.getParameterTypes()[0]));
    // 反射调用工厂方法进行转换
    return ReflectionUtils.invokeMethod(finder, source, id);
}

// org.springframework.util.ReflectionUtils#invokeMethod
public static Object invokeMethod(Method method, @Nullable Object target, @Nullable Object... args) {
    try {
        // 这里直接反射调用 并没有设置 setAccessible(true)
        return method.invoke(target, args);
    }
    catch (Exception ex) {
        handleReflectionException(ex);
    }
    throw new IllegalStateException("Should never get here");
}
```

`IdToEntityConverter` 在进行转换时先将源 ID 对象转换为工厂方法的参数类型，由于在 `matches` 已经验证过了，所以这里是可以进行转换的；比如 ID 类型为 `String`，实体类型为 `Pookie`，工厂方法为 `findPookie(Integer)`，需要先将 `String` 类型的 ID 转换为 `Integer` 类型，然后在反射调用工厂方法 `findPookie(Integer)` 完成实体类型转换。

**测试用例**

```java
public class Pookie {

    // Ignore properties

    // use for {@link org.springframework.core.convert.support.IdToEntityConverter}
    public static Pookie findPookie(Integer id){
        Pookie pookie = new Pookie();
        pookie.setId(id);
        pookie.setName("From:findPookie");
        pookie.setColor(Color.GREEN);
        return pookie;
    }

    // use for org.springframework.core.convert.support.ObjectToObjectConverter
    public Color toColor(){
        return this.color;
    }
}
```

```java
@Test
public void test03() throws Exception {
    // Method m = Pookie.class.getMethod("findPookie", Integer.class);
    // 反射调用静态方法无需对象
    // System.out.println(m.invoke(null, 1));
    
    // 将 String 类型的 ID 转换为 Pookie 实体对象
    Pookie pookie = conversionService.convert("10", Pookie.class);
    System.out.println(pookie);
    
    // 将 Pookie 对象转换为 Color 对象
    Color color = conversionService.convert(pookie, Color.class);
    System.out.println(color);
}
```

**控制台输出**

```console
Pookie[id=10, name='From:findPookie', age=0, birth=null, nums=null, circle=null, color=GREEN]
GREEN
```

## Spring 中的使用

```xml
<bean id="conversionService"
        class="org.springframework.context.support.ConversionServiceFactoryBean">
    <property name="converters">
        <set>
            <bean class="example.MyCustomConverter"/>
        </set>
    </property>
</bean>
```

在 `ApplicationContext` 初始化的时候，会查询 `id = conversionService` 的 `ConversionService` 对象，然后调用 `BeanFactory` 的 `setConversionService` 方法设置为 `Spring` 容器的类型转换器。

```java
// org.springframework.context.support.AbstractApplicationContext#refresh#finishBeanFactoryInitialization
protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
    // String CONVERSION_SERVICE_BEAN_NAME = "conversionService"
    // Initialize conversion service for this context.
    if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &&
            beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {
        beanFactory.setConversionService(
                beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));
    }
    // ...
}
```

`BeanFactory` 只能配置一个 `ConversionService`，如果不需要格式化功能则只需配置为 `ConversionServiceFactoryBean`，当需要格式化的时候则使用 `FormattingConversionServiceFactoryBean`。通过 `ConversionServiceFactoryBean` 最终会创建一个 `DefaultConversionService` 作为转换器，通过 `FormattingConversionServiceFactoryBean` 则会创建一个 `DefaultFormattingConversionService` 转换器，后者是对前者的扩展，在类型转换的基础上增加了字符串格式化转换功能。



---

## 参考

+ [Spring类型转换器(二)](https://www.jianshu.com/p/931b9610cbb7)

+ [spring类型转换器(四)](https://www.jianshu.com/p/a0ee9ce8058c)

+ [Java中的泛型类型擦除](https://blog.csdn.net/cpcpcp123/article/details/115141681)

---
