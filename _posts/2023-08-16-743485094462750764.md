---
layout: post
title: SpringMVC 数据类型转换分析
date: 2023-08-16
category: Spring
tags: [Spring MVC]
excerpt: 
---

## 命名空间处理器 NamespaceHandler

Spring 在解析 XML 时，最后会委派 DefaultBeanDefinitionDocumentReader 类解析。而每个 XML 标签会有不同的命名空间，每个命名空间都有自己的解析器，例如 AopNamespaceHandler、ContextNamespaceHandler、MvcNamespaceHandler。

org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#parseBeanDefinitions

```java
protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
	// 命令空间为空或Beans命名空间(默认) 标签：beans、import、bean、alias
	if (delegate.isDefaultNamespace(root)) {
		NodeList nl = root.getChildNodes();
		for (int i = 0; i < nl.getLength(); i++) {
			Node node = nl.item(i);
			if (node instanceof Element) {
				Element ele = (Element) node;
				// 嵌套解析
				if (delegate.isDefaultNamespace(ele)) {
					parseDefaultElement(ele, delegate);
				}
				else {
					delegate.parseCustomElement(ele);
				}
			}
		}
	}
	else {
		// Mvc、Aop、Context 等其它命名空间
		delegate.parseCustomElement(root);
	}
}
```

当遇到一个命名空间标签前缀时会调用相应的解析器，例如 \<context:component-scan base-package="abc"\> 最终调用 ContextNamespaceHandler 内部的 ComponentScanBeanDefinitionParser#parse 将扫描路径中的类注册到容器，源码如下：

```java
public BeanDefinition parse(Element element, ParserContext parserContext) {
	String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE);
	basePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage);
	String[] basePackages = StringUtils.tokenizeToStringArray(basePackage,
			ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);

	// Actually scan for bean definitions and register them.
	ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);
	// 实际注册方法
	Set<BeanDefinitionHolder> beanDefinitions = scanner.doScan(basePackages);
	registerComponents(parserContext.getReaderContext(), beanDefinitions, element);

	return null;
}
```

## 初始化 MVC 类型转换组件

如果启用 MVC 注解驱动则在容器初始化阶段加载 BeanDefinition 时注册 _请求处理、参数解析、类型转换、异常处理_ 等相关 MVC 组件。

```
<!-- 启用注解驱动 -->
<mvc:annotation-driven/>
```

### 解析与注册

org.springframework.beans.factory.xml.BeanDefinitionParserDelegate#parseCustomElement

org.springframework.beans.factory.xml.NamespaceHandlerSupport#parse

org.springframework.web.servlet.config.AnnotationDrivenBeanDefinitionParser#parse ★

PS：注册 BeanDefinition 时会把依赖的其它组件以 PropertyValue 的形式存放在 RootBeanDefinition，如果 propertyValue 是 BeanDefinition 则在依赖注入时会 createBean()；如果是 RuntimeBeanReference 则会从容器中获取 getBean()；

依赖属性解析：org.springframework.beans.factory.support.BeanDefinitionValueResolver#resolveValueIfNecessary

1)、注册 RequestMappingHandlerMapping

```java
RootBeanDefinition handlerMappingDef = new RootBeanDefinition(RequestMappingHandlerMapping.class);
handlerMappingDef.setSource(source);
handlerMappingDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
handlerMappingDef.getPropertyValues().add("order", 0);
handlerMappingDef.getPropertyValues().add("contentNegotiationManager", contentNegotiationManager);

if (element.hasAttribute("enable-matrix-variables")) {
	Boolean enableMatrixVariables = Boolean.valueOf(element.getAttribute("enable-matrix-variables"));
	handlerMappingDef.getPropertyValues().add("removeSemicolonContent", !enableMatrixVariables);
}

configurePathMatchingProperties(handlerMappingDef, element, parserContext);
readerContext.getRegistry().registerBeanDefinition(HANDLER_MAPPING_BEAN_NAME , handlerMappingDef);
```

2)、注册 FormattingConversionServiceFactoryBean (webMvc 默认类型转换器)

```java
RuntimeBeanReference conversionService = getConversionService(element, source, parserContext);
RuntimeBeanReference validator = getValidator(element, source, parserContext);
RuntimeBeanReference messageCodesResolver = getMessageCodesResolver(element);

// 注:conversionService#FactoryBean 初次初始化由以下拦截器初始化时触发
RootBeanDefinition csInterceptorDef = new RootBeanDefinition(ConversionServiceExposingInterceptor.class);
csInterceptorDef.setSource(source);
csInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(0, conversionService);
RootBeanDefinition mappedCsInterceptorDef = new RootBeanDefinition(MappedInterceptor.class);
mappedCsInterceptorDef.setSource(source);
mappedCsInterceptorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
mappedCsInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(0, (Object) null);
mappedCsInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(1, csInterceptorDef);
String mappedInterceptorName = readerContext.registerWithGeneratedName(mappedCsInterceptorDef);
```

org.springframework.web.servlet.config.AnnotationDrivenBeanDefinitionParser#getConversionService

```java
private RuntimeBeanReference getConversionService(
		Element element, @Nullable Object source, ParserContext parserContext) {

	RuntimeBeanReference conversionServiceRef;
	// 如果 mvc 标签指定则不使用下面的默认转换器
	if (element.hasAttribute("conversion-service")) {
		conversionServiceRef = new RuntimeBeanReference(element.getAttribute("conversion-service"));
	}
	else {
		RootBeanDefinition conversionDef = new RootBeanDefinition(FormattingConversionServiceFactoryBean.class);
		conversionDef.setSource(source);
		conversionDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
		// 注册 BeanDefinition
		String conversionName = parserContext.getReaderContext().registerWithGeneratedName(conversionDef);
		parserContext.registerComponent(new BeanComponentDefinition(conversionDef, conversionName));
		conversionServiceRef = new RuntimeBeanReference(conversionName);
	}
	return conversionServiceRef;
}
```

3)、注册 ConfigurableWebBindingInitializer

创建 RootBeanDefinition 时会绑定第二步注册的 DefaultFormattingConversionService

```java
RootBeanDefinition bindingDef = new RootBeanDefinition(ConfigurableWebBindingInitializer.class);
bindingDef.setSource(source);
bindingDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
bindingDef.getPropertyValues().add("conversionService", conversionService);
bindingDef.getPropertyValues().add("validator", validator);
bindingDef.getPropertyValues().add("messageCodesResolver", messageCodesResolver);
```

4)、注册 RequestMappingHandlerAdapter

这里会绑定已注册的 webBindingInitializer、messageConverters 等其它组件

```java
ManagedList<?> messageConverters = getMessageConverters(element, source, parserContext);
ManagedList<?> argumentResolvers = getArgumentResolvers(element, parserContext);
ManagedList<?> returnValueHandlers = getReturnValueHandlers(element, parserContext);
String asyncTimeout = getAsyncTimeout(element);
RuntimeBeanReference asyncExecutor = getAsyncExecutor(element);
ManagedList<?> callableInterceptors = getCallableInterceptors(element, source, parserContext);
ManagedList<?> deferredResultInterceptors = getDeferredResultInterceptors(element, source, parserContext);

RootBeanDefinition handlerAdapterDef = new RootBeanDefinition(RequestMappingHandlerAdapter.class);
handlerAdapterDef.setSource(source);
handlerAdapterDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
handlerAdapterDef.getPropertyValues().add("contentNegotiationManager", contentNegotiationManager);
handlerAdapterDef.getPropertyValues().add("webBindingInitializer", bindingDef);
handlerAdapterDef.getPropertyValues().add("messageConverters", messageConverters);
addRequestBodyAdvice(handlerAdapterDef);
addResponseBodyAdvice(handlerAdapterDef);

if (element.hasAttribute("ignore-default-model-on-redirect")) {
	Boolean ignoreDefaultModel = Boolean.valueOf(element.getAttribute("ignore-default-model-on-redirect"));
	handlerAdapterDef.getPropertyValues().add("ignoreDefaultModelOnRedirect", ignoreDefaultModel);
}
if (argumentResolvers != null) {
	handlerAdapterDef.getPropertyValues().add("customArgumentResolvers", argumentResolvers);
}
if (returnValueHandlers != null) {
	handlerAdapterDef.getPropertyValues().add("customReturnValueHandlers", returnValueHandlers);
}
if (asyncTimeout != null) {
	handlerAdapterDef.getPropertyValues().add("asyncRequestTimeout", asyncTimeout);
}
if (asyncExecutor != null) {
	handlerAdapterDef.getPropertyValues().add("taskExecutor", asyncExecutor);
}

handlerAdapterDef.getPropertyValues().add("callableInterceptors", callableInterceptors);
handlerAdapterDef.getPropertyValues().add("deferredResultInterceptors", deferredResultInterceptors);
readerContext.getRegistry().registerBeanDefinition(HANDLER_ADAPTER_BEAN_NAME , handlerAdapterDef);
```

### 初始化 MVC 组件

注册相关 BeanDefinition 后在 refresh() 方法中调用 finishBeanFactoryInitialization() 进行预初始化。

随后已经初始化的 MVC 组件在 onRefresh() -> initStrategies() 注册到 DispatcherServlet。

注：如果没有配置 MVC 类型转换，则默认使用初始化第二步中注册的 DefaultFormattingConversionService。

## MVC 默认参数解析器

默认参数解析器在 RequestMappingHandlerAdapter 初始化时设置，在解析参数值时会使用上文创建的类型转换器。

org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#afterPropertiesSet

```java
public void afterPropertiesSet() {
	// Do this first, it may add ResponseBody advice beans
	initControllerAdviceCache();

	if (this.argumentResolvers == null) {
		List<HandlerMethodArgumentResolver> resolvers = getDefaultArgumentResolvers();
		this.argumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers);
	}
	if (this.initBinderArgumentResolvers == null) {
		List<HandlerMethodArgumentResolver> resolvers = getDefaultInitBinderArgumentResolvers();
		this.initBinderArgumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers);
	}
	if (this.returnValueHandlers == null) {
		List<HandlerMethodReturnValueHandler> handlers = getDefaultReturnValueHandlers();
		this.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);
	}
}
```

### DefaultArgumentResolvers

```java
/**
 * Return the list of argument resolvers to use including built-in resolvers
 * and custom resolvers provided via {@link #setCustomArgumentResolvers}.
 */
private List<HandlerMethodArgumentResolver> getDefaultArgumentResolvers() {
	List<HandlerMethodArgumentResolver> resolvers = new ArrayList<>();

	// Annotation-based argument resolution
	resolvers.add(new RequestParamMethodArgumentResolver(getBeanFactory(), false));
	resolvers.add(new RequestParamMapMethodArgumentResolver());
	resolvers.add(new PathVariableMethodArgumentResolver());
	resolvers.add(new PathVariableMapMethodArgumentResolver());
	resolvers.add(new MatrixVariableMethodArgumentResolver());
	resolvers.add(new MatrixVariableMapMethodArgumentResolver());
	resolvers.add(new ServletModelAttributeMethodProcessor(false));
	resolvers.add(new RequestResponseBodyMethodProcessor(getMessageConverters(), this.requestResponseBodyAdvice));
	resolvers.add(new RequestPartMethodArgumentResolver(getMessageConverters(), this.requestResponseBodyAdvice));
	resolvers.add(new RequestHeaderMethodArgumentResolver(getBeanFactory()));
	resolvers.add(new RequestHeaderMapMethodArgumentResolver());
	resolvers.add(new ServletCookieValueMethodArgumentResolver(getBeanFactory()));
	resolvers.add(new ExpressionValueMethodArgumentResolver(getBeanFactory()));
	resolvers.add(new SessionAttributeMethodArgumentResolver());
	resolvers.add(new RequestAttributeMethodArgumentResolver());

	// Type-based argument resolution
	resolvers.add(new ServletRequestMethodArgumentResolver());
	resolvers.add(new ServletResponseMethodArgumentResolver());
	resolvers.add(new HttpEntityMethodProcessor(getMessageConverters(), this.requestResponseBodyAdvice));
	resolvers.add(new RedirectAttributesMethodArgumentResolver());
	resolvers.add(new ModelMethodProcessor());
	resolvers.add(new MapMethodProcessor());
	resolvers.add(new ErrorsMethodArgumentResolver());
	resolvers.add(new SessionStatusMethodArgumentResolver());
	resolvers.add(new UriComponentsBuilderMethodArgumentResolver());

	// Custom arguments
	if (getCustomArgumentResolvers() != null) {
		resolvers.addAll(getCustomArgumentResolvers());
	}

	// Catch-all

	// 无注解的 String、基本数据类型等
	resolvers.add(new RequestParamMethodArgumentResolver(getBeanFactory(), true));
	// @ModelAttribute注解类 或 无注解的非基本数据类型实体类
	resolvers.add(new ServletModelAttributeMethodProcessor(true));

	return resolvers;
}
```

### InitBinderArgumentResolvers

```java
/**
 * Return the list of argument resolvers to use for {@code @InitBinder}
 * methods including built-in and custom resolvers.
 */
private List<HandlerMethodArgumentResolver> getDefaultInitBinderArgumentResolvers() {
	List<HandlerMethodArgumentResolver> resolvers = new ArrayList<>();

	// Annotation-based argument resolution
	resolvers.add(new RequestParamMethodArgumentResolver(getBeanFactory(), false));
	resolvers.add(new RequestParamMapMethodArgumentResolver());
	resolvers.add(new PathVariableMethodArgumentResolver());
	resolvers.add(new PathVariableMapMethodArgumentResolver());
	resolvers.add(new MatrixVariableMethodArgumentResolver());
	resolvers.add(new MatrixVariableMapMethodArgumentResolver());
	resolvers.add(new ExpressionValueMethodArgumentResolver(getBeanFactory()));
	resolvers.add(new SessionAttributeMethodArgumentResolver());
	resolvers.add(new RequestAttributeMethodArgumentResolver());

	// Type-based argument resolution
	resolvers.add(new ServletRequestMethodArgumentResolver());
	resolvers.add(new ServletResponseMethodArgumentResolver());

	// Custom arguments
	if (getCustomArgumentResolvers() != null) {
		resolvers.addAll(getCustomArgumentResolvers());
	}

	// Catch-all
	resolvers.add(new RequestParamMethodArgumentResolver(getBeanFactory(), true));

	return resolvers;
}
```

### ReturnValueHandlers

```java
/**
 * Return the list of return value handlers to use including built-in and
 * custom handlers provided via {@link #setReturnValueHandlers}.
 */
private List<HandlerMethodReturnValueHandler> getDefaultReturnValueHandlers() {
	List<HandlerMethodReturnValueHandler> handlers = new ArrayList<>();

	// Single-purpose return value types
	handlers.add(new ModelAndViewMethodReturnValueHandler());
	handlers.add(new ModelMethodProcessor());
	handlers.add(new ViewMethodReturnValueHandler());
	handlers.add(new ResponseBodyEmitterReturnValueHandler(getMessageConverters(),
			this.reactiveRegistry, this.taskExecutor, this.contentNegotiationManager));
	handlers.add(new StreamingResponseBodyReturnValueHandler());
	handlers.add(new HttpEntityMethodProcessor(getMessageConverters(),
			this.contentNegotiationManager, this.requestResponseBodyAdvice));
	handlers.add(new HttpHeadersReturnValueHandler());
	handlers.add(new CallableMethodReturnValueHandler());
	handlers.add(new DeferredResultMethodReturnValueHandler());
	handlers.add(new AsyncTaskMethodReturnValueHandler(this.beanFactory));

	// Annotation-based return value types
	handlers.add(new ModelAttributeMethodProcessor(false));
	handlers.add(new RequestResponseBodyMethodProcessor(getMessageConverters(),
			this.contentNegotiationManager, this.requestResponseBodyAdvice));

	// Multi-purpose return value types
	handlers.add(new ViewNameMethodReturnValueHandler());
	handlers.add(new MapMethodProcessor());

	// Custom return value types
	if (getCustomReturnValueHandlers() != null) {
		handlers.addAll(getCustomReturnValueHandlers());
	}

	// Catch-all
	if (!CollectionUtils.isEmpty(getModelAndViewResolvers())) {
		handlers.add(new ModelAndViewResolverMethodReturnValueHandler(getModelAndViewResolvers()));
	}
	else {
		handlers.add(new ModelAttributeMethodProcessor(true));
	}

	return handlers;
}
```

## 自定义类型转换器

自定义类型转换器需实现 Convert\<T, S\> 接口：

```java
public class StringToDateConverter implements Converter<String, Date> {

	SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

	@Override
	public Date convert(String source) {
		Date date = null;
		if(StringUtils.hasLength(source)){
			try {
				date = format.parse(source);
			} catch (ParseException e) {
				e.printStackTrace();
			}
		}
		return date;
	}
}
```

在配置文件中声明转换器：

```xml
<bean id="conversionService" class="org.springframework.context.support.ConversionServiceFactoryBean">
    <property name="converters">
        <list>
            <!-- 声明自定义类型转换器 -->
            <bean class="spring.demo.configures.conversion.StringToDateConverter"/>
        </list>
    </property>
</bean>
```

在 \<annotation-driven\> 中引用转换器：

```xml
<!-- 启用MVC注解驱动 -->
<mvc:annotation-driven conversion-service="conversionService"/>
```

浏览器测试：`http://localhost:8080/convert?name=Tom&traceId=4462750764&birth=2022-12-31%2002:21:02&file=test.xml`

在请求到达 Controller 时如果参数类型匹配则自动转换：Person 参数使用的是 ServletModelAttributeMethodProcessor 解析器，String 参数 traceId 使用的是 RequestParamMethodArgumentResolver 解析器。注：本测试使用的测试参数均为GET路径参数；如果参数在请求体中，则需要给对应的参数添加 @RequestBody 注解。

```java
@GetMapping("/convert")
@ResponseBody
public String testConversion(Person person, String traceId){
	logger.info("step into conversion -> {}", person);
	JSONObject jsonObject = new JSONObject();
	jsonObject.put("person" , person);
	jsonObject.put("traceId", traceId);
	jsonObject.put("code", "200");
	jsonObject.put("msg", "OK");
	return jsonObject.toJSONString();
}

public class Person {
	private String name;
	private int age;
	private Date birth;
	private File file;
}
```

## MVC 请求参数解析路径


### ServletModelAttributeMethodProcessor

解析参数入口方法：org.springframework.web.method.annotation.ModelAttributeMethodProcessor#resolveArgument

```java
public final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,
		NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {

	Assert.state(mavContainer != null, "ModelAttributeMethodProcessor requires ModelAndViewContainer");
	Assert.state(binderFactory != null, "ModelAttributeMethodProcessor requires WebDataBinderFactory");

	String name = ModelFactory.getNameForParameter(parameter);
	ModelAttribute ann = parameter.getParameterAnnotation(ModelAttribute.class);
	if (ann != null) {
		mavContainer.setBinding(name, ann.binding());
	}

	Object attribute = null;
	BindingResult bindingResult = null;

	if (mavContainer.containsAttribute(name)) {
		attribute = mavContainer.getModel().get(name);
	}
	else {
		// Create attribute instance
		try {
			// 将请求参数封装为当前参数类型的对象(还没有赋值)
			attribute = createAttribute(name, parameter, binderFactory, webRequest);
		}
		catch (BindException ex) {
			if (isBindExceptionRequired(parameter)) {
				// No BindingResult parameter -> fail with BindException
				throw ex;
			}
			// Otherwise, expose null/empty value and associated BindingResult
			if (parameter.getParameterType() == Optional.class) {
				attribute = Optional.empty();
			}
			bindingResult = ex.getBindingResult();
		}
	}

	if (bindingResult == null) {
		// Bean property binding and validation;
		// skipped in case of binding failure on construction.

		// 将用于接收参数的 attribute 对象封装在 dataBinder
		WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name);
		if (binder.getTarget() != null) {
			if (!mavContainer.isBindingDisabled(name)) {
				// 将请求参数的值经过类型转换后赋给 attribute
				bindRequestParameters(binder, webRequest);
			}
			validateIfApplicable(binder, parameter);
			if (binder.getBindingResult().hasErrors() && isBindExceptionRequired(binder, parameter)) {
				throw new BindException(binder.getBindingResult());
			}
		}
		// Value type adaptation, also covering java.util.Optional
		if (!parameter.getParameterType().isInstance(attribute)) {
			attribute = binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter);
		}
		bindingResult = binder.getBindingResult();
	}

	// Add resolved attribute and BindingResult at the end of the model
	Map<String, Object> bindingResultModel = bindingResult.getModel();
	mavContainer.removeAttributes(bindingResultModel);
	mavContainer.addAllAttributes(bindingResultModel);

	// 返回已经解析的参数对象
	return attribute;
}
```

org.springframework.web.method.annotation.ModelAttributeMethodProcessor#createAttribute

```java
protected Object createAttribute(String attributeName, MethodParameter parameter,
		WebDataBinderFactory binderFactory, NativeWebRequest webRequest) throws Exception {

	MethodParameter nestedParameter = parameter.nestedIfOptional();
	Class<?> clazz = nestedParameter.getNestedParameterType();

	Constructor<?> ctor = BeanUtils.findPrimaryConstructor(clazz);
	if (ctor == null) {
		Constructor<?>[] ctors = clazz.getConstructors();
		if (ctors.length == 1) {
			ctor = ctors[0];
		}
		else {
			try {
				// 反射获取构造函数
				ctor = clazz.getDeclaredConstructor();
			}
			catch (NoSuchMethodException ex) {
				throw new IllegalStateException("No primary or default constructor found for " + clazz, ex);
			}
		}
	}
	// 构造函数创建实例
	Object attribute = constructAttribute(ctor, attributeName, binderFactory, webRequest);
	if (parameter != nestedParameter) {
		attribute = Optional.of(attribute);
	}
	return attribute;
}
```


org.springframework.web.servlet.mvc.method.annotation.ServletModelAttributeMethodProcessor#bindRequestParameters

```java
protected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request) {
	ServletRequest servletRequest = request.getNativeRequest(ServletRequest.class);
	Assert.state(servletRequest != null, "No ServletRequest");
	ServletRequestDataBinder servletBinder = (ServletRequestDataBinder) binder;
	servletBinder.bind(servletRequest);
}
```

org.springframework.web.bind.ServletRequestDataBinder#bind

```java
public void bind(ServletRequest request) {
	MutablePropertyValues mpvs = new ServletRequestParameterPropertyValues(request);
	MultipartRequest multipartRequest = WebUtils.getNativeRequest(request, MultipartRequest.class);
	if (multipartRequest != null) {
		bindMultipart(multipartRequest.getMultiFileMap(), mpvs);
	}
	// 将请求参数也就是实参封装到 PropertyValues
	addBindValues(mpvs, request);
	// 真正开始赋值：将实参的值赋值给形参
	doBind(mpvs);
}
```
doBind(mpvs) 最终调用 DataBinder -> applyPropertyValues 进行赋值，在该方法中通过 DataBinder#getPropertyAccessor 将之前封装在 DataBinder 中的 attribute 又封装为一个 BeanWrapperImpl，然后将 dataBinder 的 conversionService (类型转换器)赋值给 BeanWrapperImpl ，最后调用 BeanWrapperImpl -> setPropertyValues 进行实参类型转换与赋值，即首先封装一个带有类型转换器的形参壳：BeanWrapperImpl，然后再封装一个含有实参的容器：PropertyValues，最后进行实参到形参的转换。


__解析参数时类型转换器传递路线：__

![img](./img/springmvc-data-convert-flow-1.png)


org.springframework.validation.DataBinder#applyPropertyValues

```java
protected void applyPropertyValues(MutablePropertyValues mpvs) {
	try {
		// Bind request parameters onto target object.
		getPropertyAccessor().setPropertyValues(mpvs, isIgnoreUnknownFields(), isIgnoreInvalidFields());
	}
	catch (PropertyBatchUpdateException ex) {
		// Use bind error processor to create FieldErrors.
		for (PropertyAccessException pae : ex.getPropertyAccessExceptions()) {
			getBindingErrorProcessor().processPropertyAccessException(pae, getInternalBindingResult());
		}
	}
}
```

org.springframework.validation.DataBinder#getPropertyAccessor

```java
/**
 * Return the underlying PropertyAccessor of this binder's BindingResult.
 */
protected ConfigurablePropertyAccessor getPropertyAccessor() {
	return getInternalBindingResult().getPropertyAccessor();
}
```

org.springframework.validation.DataBinder#createBeanPropertyBindingResult

```java
protected AbstractPropertyBindingResult createBeanPropertyBindingResult() {
	BeanPropertyBindingResult result = new BeanPropertyBindingResult(getTarget(),
			getObjectName(), isAutoGrowNestedPaths(), getAutoGrowCollectionLimit());

	if (this.conversionService != null) {
		// 将当前DataBinder的类型转换器赋值给BeanWrapper
		result.initConversion(this.conversionService);
	}
	if (this.messageCodesResolver != null) {
		result.setMessageCodesResolver(this.messageCodesResolver);
	}

	return result;
}
```

org.springframework.validation.AbstractPropertyBindingResult#initConversion

```java
public void initConversion(ConversionService conversionService) {
	Assert.notNull(conversionService, "ConversionService must not be null");
	this.conversionService = conversionService;
	if (getTarget() != null) {
		// 实际创建的是BeanWrapperImpl
		getPropertyAccessor().setConversionService(conversionService);
	}
}
```

org.springframework.validation.BeanPropertyBindingResult#getPropertyAccessor

```java
public final ConfigurablePropertyAccessor getPropertyAccessor() {
	if (this.beanWrapper == null) {
		this.beanWrapper = createBeanWrapper();
		this.beanWrapper.setExtractOldValueForEditor(true);
		this.beanWrapper.setAutoGrowNestedPaths(this.autoGrowNestedPaths);
		this.beanWrapper.setAutoGrowCollectionLimit(this.autoGrowCollectionLimit);
	}
	return this.beanWrapper;
}
```

org.springframework.beans.AbstractPropertyAccessor#setPropertyValues

```java
public void setPropertyValues(PropertyValues pvs, boolean ignoreUnknown, boolean ignoreInvalid)
		throws BeansException {

	List<PropertyAccessException> propertyAccessExceptions = null;
	List<PropertyValue> propertyValues = (pvs instanceof MutablePropertyValues ?
			((MutablePropertyValues) pvs).getPropertyValueList() : Arrays.asList(pvs.getPropertyValues()));
	// 遍历每个实参：类型转换 + 赋值
	for (PropertyValue pv : propertyValues) {
		try {
			// This method may throw any BeansException, which won't be caught
			// here, if there is a critical failure such as no matching field.
			// We can attempt to deal only with less serious exceptions.
			setPropertyValue(pv);
		}
		catch (NotWritablePropertyException ex) {
			// ...
		}
	}
	// If we encountered individual exceptions, throw the composite exception.
	if (propertyAccessExceptions != null) {
		PropertyAccessException[] paeArray =
				propertyAccessExceptions.toArray(new PropertyAccessException[propertyAccessExceptions.size()]);
		throw new PropertyBatchUpdateException(paeArray);
	}
}
```

org.springframework.beans.AbstractNestablePropertyAccessor#convertIfNecessary

```java
private Object convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue,
		@Nullable Object newValue, @Nullable Class<?> requiredType, @Nullable TypeDescriptor td)
		throws TypeMismatchException {

	Assert.state(this.typeConverterDelegate != null, "No TypeConverterDelegate");
	try {
		// 实际委派给 typeConverterDelegate 进行类型转换
		return this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, newValue, requiredType, td);
	}
	catch (ConverterNotFoundException | IllegalStateException ex) {
		// ...
	}
}
```
TypeConvertDelegate 在初始化 BeanWrapperImpl 的父类构造方法创建：

org.springframework.beans.AbstractNestablePropertyAccessor#setWrappedInstance

```java
public void setWrappedInstance(Object object, @Nullable String nestedPath, @Nullable Object rootObject) {
	this.wrappedObject = ObjectUtils.unwrapOptional(object);
	Assert.notNull(this.wrappedObject, "Target object must not be null");
	this.nestedPath = (nestedPath != null ? nestedPath : "");
	this.rootObject = (!"".equals(this.nestedPath) ? rootObject : this.wrappedObject);
	this.nestedPropertyAccessors = null;
	this.typeConverterDelegate = new TypeConverterDelegate(this, this.wrappedObject);
}
```

__参数类型转换与赋值方法调用路线：__


![img](./img/springmvc-data-convert-flow-2.png)


### RequestParamMethodArgumentResolver


org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#invokeHandlerMethod

```java
protected ModelAndView invokeHandlerMethod(HttpServletRequest request,
		HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {

	ServletWebRequest webRequest = new ServletWebRequest(request, response);

	try {
		// 创建数据绑定工厂
		WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);
		// 创建模型工厂
		ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);
		// 封装执行方法
		ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);
		if (this.argumentResolvers != null) {
			// 设置方法参数解析器(从当前HandlerAdapter获取)
			invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);
		}
		if (this.returnValueHandlers != null) {
			// 设置方法返回值解析器(从当前HandlerAdapter获取)
			invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);
		}
		// 设置数据绑定工厂
		invocableMethod.setDataBinderFactory(binderFactory);
		// 设置方法参数名称解析器(ASM/JDK)
		invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);

		ModelAndViewContainer mavContainer = new ModelAndViewContainer();
		mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));
		modelFactory.initModel(webRequest, mavContainer, invocableMethod);
		mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);

		AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);
		asyncWebRequest.setTimeout(this.asyncRequestTimeout);

		WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);
		asyncManager.setTaskExecutor(this.taskExecutor);
		asyncManager.setAsyncWebRequest(asyncWebRequest);
		asyncManager.registerCallableInterceptors(this.callableInterceptors);
		asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);

		if (asyncManager.hasConcurrentResult()) {
			Object result = asyncManager.getConcurrentResult();
			mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0];
			asyncManager.clearConcurrentResult();
			if (logger.isDebugEnabled()) {
				logger.debug("Found concurrent result value [" + result + "]");
			}
			invocableMethod = invocableMethod.wrapConcurrentResult(result);
		}

		// 开始调用目标方法
		invocableMethod.invokeAndHandle(webRequest, mavContainer);
		
		if (asyncManager.isConcurrentHandlingStarted()) {
			return null;
		}

		// 获取MVC容器中的ModelAndView结果
		return getModelAndView(mavContainer, modelFactory, webRequest);
	}
	finally {
		webRequest.requestCompleted();
	}
}
```

org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#getModelAndView

```java
private ModelAndView getModelAndView(ModelAndViewContainer mavContainer,
		ModelFactory modelFactory, NativeWebRequest webRequest) throws Exception {

	modelFactory.updateModel(webRequest, mavContainer);

	// 如果是@ResponseBody注解的方法此处返回Null
	if (mavContainer.isRequestHandled()) {
		// 返回Null无需进行后续的视图渲染
		return null;
	}
	ModelMap model = mavContainer.getModel();
	ModelAndView mav = new ModelAndView(mavContainer.getViewName(), model, mavContainer.getStatus());
	if (!mavContainer.isViewReference()) {
		mav.setView((View) mavContainer.getView());
	}
	if (model instanceof RedirectAttributes) {
		Map<String, ?> flashAttributes = ((RedirectAttributes) model).getFlashAttributes();
		HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);
		if (request != null) {
			RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes);
		}
	}
	return mav;
}
```

org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod#invokeAndHandle

```java
public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,
		Object... providedArgs) throws Exception {

	// 调用目标方法
	Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);
	// Set the response status according to the ResponseStatus annotation.
	setResponseStatus(webRequest);

	if (returnValue == null) {
		if (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) {
			mavContainer.setRequestHandled(true);
			return;
		}
	}
	else if (StringUtils.hasText(getResponseStatusReason())) {
		mavContainer.setRequestHandled(true);
		return;
	}

	mavContainer.setRequestHandled(false);
	Assert.state(this.returnValueHandlers != null, "No return value handlers");
	try {
		// 解析目标方法返回值：如果是@ResponseBody类型的方法则内部处理完直接响应结果
		this.returnValueHandlers.handleReturnValue(
				returnValue, getReturnValueType(returnValue), mavContainer, webRequest);
	}
	catch (Exception ex) {
		if (logger.isTraceEnabled()) {
			logger.trace(getReturnValueHandlingErrorMessage("Error handling return value", returnValue), ex);
		}
		throw ex;
	}
}
```

org.springframework.web.method.support.InvocableHandlerMethod#invokeForRequest

```java
public Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,
		Object... providedArgs) throws Exception {

	// 解析请求的参数值并进行必要的类型转换
	Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);
	if (logger.isTraceEnabled()) {
		logger.trace("Invoking '" + ClassUtils.getQualifiedMethodName(getMethod(), getBeanType()) +
				"' with arguments " + Arrays.toString(args));
	}
	// 反射执行目标方法并获取返回值
	Object returnValue = doInvoke(args);
	if (logger.isTraceEnabled()) {
		logger.trace("Method [" + ClassUtils.getQualifiedMethodName(getMethod(), getBeanType()) +
				"] returned [" + returnValue + "]");
	}
	return returnValue;
}
```

org.springframework.web.method.support.InvocableHandlerMethod#getMethodArgumentValues

```java
private Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,
		Object... providedArgs) throws Exception {

	// 获取目标方法的形参列表
	MethodParameter[] parameters = getMethodParameters();
	// 创建用于存放实参的数组
	Object[] args = new Object[parameters.length];
	for (int i = 0; i < parameters.length; i++) {
		MethodParameter parameter = parameters[i];
		// 设置参数名称解析器
		parameter.initParameterNameDiscovery(this.parameterNameDiscoverer);
		// 如果调用前提供了参数值则直接使用(默认没有提供)
		args[i] = resolveProvidedArgument(parameter, providedArgs);
		if (args[i] != null) {
			continue;
		}
		if (this.argumentResolvers.supportsParameter(parameter)) {
			try {
				// 真正解析请求参数的入口，每个参数都走一遍解析流程
				// 注意：此处将数据绑定工厂也传给了参数解析器
				args[i] = this.argumentResolvers.resolveArgument(
						parameter, mavContainer, request, this.dataBinderFactory);
				continue;
			}
			catch (Exception ex) {
				if (logger.isDebugEnabled()) {
					logger.debug(getArgumentResolutionErrorMessage("Failed to resolve", i), ex);
				}
				throw ex;
			}
		}
		if (args[i] == null) {
			throw new IllegalStateException("Could not resolve method parameter at index " +
					parameter.getParameterIndex() + " in " + parameter.getExecutable().toGenericString() +
					": " + getArgumentResolutionErrorMessage("No suitable resolver for", i));
		}
	}
	return args;
}
```

解析参数入口方法：org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver#resolveArgument

```java
public final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,
		NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {

	// 获取当前参数的名称信息，如果参数有@RequestParam修饰则使用注解值初始化，否则使用默认值！
	// 注解默认值：(name="",required=true,value=DEFAULT_NONE) 无注解默认值：(name="",requred=false,value=DEFAULT_NONE)
	NamedValueInfo namedValueInfo = getNamedValueInfo(parameter);
	MethodParameter nestedParameter = parameter.nestedIfOptional();
	// 解析给定的注解值，该值可能包含占位符和表达式。
	Object resolvedName = resolveStringValue(namedValueInfo.name);
	if (resolvedName == null) {
		throw new IllegalArgumentException(
				"Specified name must not resolve to null: [" + namedValueInfo.name + "]");
	}
	// 获取请求的实参值 -> request.getParamValue(name);
	Object arg = resolveName(resolvedName.toString(), nestedParameter, webRequest);
	if (arg == null) {
		// 实参值不存在 -> 设置为默认值
		if (namedValueInfo.defaultValue != null) {
			arg = resolveStringValue(namedValueInfo.defaultValue);
		}
		// 如果默认值为Null且参数类型不是Optional也没有@Nullable注解
		else if (namedValueInfo.required && !nestedParameter.isOptional()) {
			// 抛出异常
			handleMissingValue(namedValueInfo.name, nestedParameter, webRequest);
		}
		// 处理解析默认值可能出现的空值
		arg = handleNullValue(namedValueInfo.name, arg, nestedParameter.getNestedParameterType());
	}
	// 获取的实参值为空串且默认值不为Null时使用默认值
	else if ("".equals(arg) && namedValueInfo.defaultValue != null) {
		arg = resolveStringValue(namedValueInfo.defaultValue);
	}

	if (binderFactory != null) {

		// 使用数据绑定工厂初始化一个DataBinder
		// 注：这里传了一个 target = Null 的参数，即构造的 DateBinder 持有的目标对象是 Null
		WebDataBinder binder = binderFactory.createBinder(webRequest, null, namedValueInfo.name);
		try {
			// 使用DataBinder转换数据类型
			arg = binder.convertIfNecessary(arg, parameter.getParameterType(), parameter);
		}
		catch (ConversionNotSupportedException ex) {
			throw new MethodArgumentConversionNotSupportedException(arg, ex.getRequiredType(),
					namedValueInfo.name, parameter, ex.getCause());
		}
		catch (TypeMismatchException ex) {
			throw new MethodArgumentTypeMismatchException(arg, ex.getRequiredType(),
					namedValueInfo.name, parameter, ex.getCause());

		}
	}

	// Invoked after a value is resolved.(默认实现为空)
	handleResolvedValue(arg, namedValueInfo.name, parameter, mavContainer, webRequest);

	return arg;
}
```

此处的数据绑定工厂是在前面 invokeHandlerMethod 时创建的 ServletRequestDataBinderFactory；工厂的构造参数 BindingInitializer 在初始化 HandlerAdapter 时就已经创建好，用于创建 DataBinder 时为其设置必要的类型转换器 conversionService、数据校验器 validator 等相关组件。

org.springframework.web.bind.support.DefaultDataBinderFactory#createBinder

```java
public final WebDataBinder createBinder(
		NativeWebRequest webRequest, @Nullable Object target, String objectName) throws Exception {
	// 实际创建的是 ExtendedServletRequestDataBinder
	WebDataBinder dataBinder = createBinderInstance(target, objectName, webRequest);
	if (this.initializer != null) {
		this.initializer.initBinder(dataBinder, webRequest);
	}
	initBinder(dataBinder, webRequest);
	return dataBinder;
}
```

org.springframework.web.bind.support.ConfigurableWebBindingInitializer#initBinder

```java
public void initBinder(WebDataBinder binder) {
	binder.setAutoGrowNestedPaths(this.autoGrowNestedPaths);
	if (this.directFieldAccess) {
		binder.initDirectFieldAccess();
	}
	if (this.messageCodesResolver != null) {
		binder.setMessageCodesResolver(this.messageCodesResolver);
	}
	if (this.bindingErrorProcessor != null) {
		binder.setBindingErrorProcessor(this.bindingErrorProcessor);
	}
	if (this.validator != null && binder.getTarget() != null &&
			this.validator.supports(binder.getTarget().getClass())) {
		binder.setValidator(this.validator);
	}
	if (this.conversionService != null) {
		binder.setConversionService(this.conversionService);
	}
	if (this.propertyEditorRegistrars != null) {
		for (PropertyEditorRegistrar propertyEditorRegistrar : this.propertyEditorRegistrars) {
			propertyEditorRegistrar.registerCustomEditors(binder);
		}
	}
}
```

org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#createDataBinderFactory

```java
protected InitBinderDataBinderFactory createDataBinderFactory(List<InvocableHandlerMethod> binderMethods)
		throws Exception {
	// 初始化数据绑定工厂：构造参数 WebBindingInitializer 在工厂创建 DataBinder 实例时使用
	return new ServletRequestDataBinderFactory(binderMethods, getWebBindingInitializer());
}
```

#### 数据转换入口

org.springframework.validation.DataBinder#convertIfNecessary

```java
public <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,
		@Nullable MethodParameter methodParam) throws TypeMismatchException {

	// 获取 DataBinder 的 TyPeConverter 进行转换
	return getTypeConverter().convertIfNecessary(value, requiredType, methodParam);
}
```

org.springframework.validation.DataBinder#getTypeConverter

```java
protected TypeConverter getTypeConverter() {
	// 如果DataBinder持有的目标对象不为Null
	if (getTarget() != null) {
		// 此处获取转换器参考上面的 ServletModelAttributeMethodProcessor
		return getInternalBindingResult().getPropertyAccessor();
	}
	// 目标对象为Null的情况
	// 由于在 AbstractNamedValueMethodArgumentResolver#resolveArgument
	// 创建 DataBinder 时设置的 target 为 Null，所以应获取此处的转换器
	else {
		return getSimpleTypeConverter();
	}
}
```

org.springframework.validation.DataBinder#getSimpleTypeConverter

```java
protected SimpleTypeConverter getSimpleTypeConverter() {
	if (this.typeConverter == null) {
		// 创建一个通用的转换器并传递 conversionService
		this.typeConverter = new SimpleTypeConverter();
		if (this.conversionService != null) {
			this.typeConverter.setConversionService(this.conversionService);
		}
	}
	return this.typeConverter;
}
```

SimpleTypeConverter 初始化时会创建一个 TypeConverterDelegate，构造参数 PropertyEditorRegistrySupport 属性又设置为自己，因为 SimpleTypeConverter 的父类 TypeConverterSupport 也实现了相关接口；TypeConverterDelegate 实际是 Spring 执行类型转换的门面类，其进行类型转换时会把具体的转换任务交给 PropertyEditorRegistrySupport 执行。

```java
public SimpleTypeConverter() {
	this.typeConverterDelegate = new TypeConverterDelegate(this);
	registerDefaultEditors();
}
```

在 DataBinder#convertIfNecessary 方法中最终使用 TypeConverterDelegate 执行类型转换

org.springframework.beans.TypeConverterSupport#convertIfNecessary
org.springframework.beans.TypeConverterSupport#doConvert

```java
private <T> T doConvert(@Nullable Object value,@Nullable Class<T> requiredType,
		@Nullable MethodParameter methodParam, @Nullable Field field) throws TypeMismatchException {

	Assert.state(this.typeConverterDelegate != null, "No TypeConverterDelegate");
	try {
		// 使用 TypeConverterDelegate 执行类型转换
		if (field != null) {
			return this.typeConverterDelegate.convertIfNecessary(value, requiredType, field);
		}
		else {
			return this.typeConverterDelegate.convertIfNecessary(value, requiredType, methodParam);
		}
	}
	catch (ConverterNotFoundException | IllegalStateException ex) {
		throw new ConversionNotSupportedException(value, requiredType, ex);
	}
	catch (ConversionException | IllegalArgumentException ex) {
		throw new TypeMismatchException(value, requiredType, ex);
	}
}
```

__参数类型转换与赋值方法调用路线：__

![img](./img/springmvc-data-convert-flow-3.png)

#### 数据类型转换核心方法 ★★★

org.springframework.beans.TypeConverterDelegate#convertIfNecessary

```java
public <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue,
		@Nullable Class<T> requiredType, @Nullable TypeDescriptor typeDescriptor) throws IllegalArgumentException {

	// Custom editor for this type?
	// 根据目标参数类型获取 PropertyEditor 转换器
	PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);

	ConversionFailedException conversionAttemptEx = null;

	// No custom editor but custom ConversionService specified?
	// 获取 conversionService：这里的 propertyEditorRegistry 就是之前创建的 SimpleTypeConverter
	ConversionService conversionService = this.propertyEditorRegistry.getConversionService();
	
	// PropertyEditor 为空且 conversionService 不为空则使用 conversionService 进行转换
	if (editor == null && conversionService != null && newValue != null && typeDescriptor != null) {
		TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);
		// 判断如果 conversionService 可以进行转换则执行转换
		if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {
			try {
				return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);
			}
			catch (ConversionFailedException ex) {
				// fallback to default conversion logic below
				conversionAttemptEx = ex;
			}
		}
	}

	Object convertedValue = newValue;

	// Value not of required type?
	// PropertyEditor 不为空 或者 conversionService 无法转换的情况下执行以下转换
	if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {
		if (typeDescriptor != null && requiredType != null && Collection.class.isAssignableFrom(requiredType) &&
				convertedValue instanceof String) {
			TypeDescriptor elementTypeDesc = typeDescriptor.getElementTypeDescriptor();
			if (elementTypeDesc != null) {
				Class<?> elementType = elementTypeDesc.getType();
				if (Class.class == elementType || Enum.class.isAssignableFrom(elementType)) {
					convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);
				}
			}
		}
		if (editor == null) {
			// PropertyEditor 为空则获取默认 PropertyEditor
			editor = findDefaultEditor(requiredType);
		}
		convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);
	}

	boolean standardConversion = false;

	if (requiredType != null) {

		// Try to apply some standard type conversion rules if appropriate.

		if (convertedValue != null) {
			if (Object.class == requiredType) {
				return (T) convertedValue;
			}
			else if (requiredType.isArray()) {
				// Array required -> apply appropriate conversion of elements.
				if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {
					convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);
				}
				return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());
			}
			else if (convertedValue instanceof Collection) {
				// Convert elements to target type, if determined.
				convertedValue = convertToTypedCollection(
						(Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor);
				standardConversion = true;
			}
			else if (convertedValue instanceof Map) {
				// Convert keys and values to respective target type, if determined.
				convertedValue = convertToTypedMap(
						(Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor);
				standardConversion = true;
			}
			if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {
				convertedValue = Array.get(convertedValue, 0);
				standardConversion = true;
			}
			if (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {
				// We can stringify any primitive value...
				return (T) convertedValue.toString();
			}
			else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {
				if (conversionAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {
					try {
						Constructor<T> strCtor = requiredType.getConstructor(String.class);
						return BeanUtils.instantiateClass(strCtor, convertedValue);
					}
					catch (NoSuchMethodException ex) {
						// proceed with field lookup
						if (logger.isTraceEnabled()) {
							logger.trace("No String constructor found on type [" + requiredType.getName() + "]", ex);
						}
					}
					catch (Exception ex) {
						if (logger.isDebugEnabled()) {
							logger.debug("Construction via String failed for type [" + requiredType.getName() + "]", ex);
						}
					}
				}
				String trimmedValue = ((String) convertedValue).trim();
				if (requiredType.isEnum() && "".equals(trimmedValue)) {
					// It's an empty enum identifier: reset the enum value to null.
					return null;
				}
				convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);
				standardConversion = true;
			}
			else if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) {
				convertedValue = NumberUtils.convertNumberToTargetClass(
						(Number) convertedValue, (Class<Number>) requiredType);
				standardConversion = true;
			}
		}
		else {
			// convertedValue == null
			if (requiredType == Optional.class) {
				convertedValue = Optional.empty();
			}
		}

		if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {
			if (conversionAttemptEx != null) {
				// Original exception from former ConversionService call above...
				throw conversionAttemptEx;
			}
			else if (conversionService != null && typeDescriptor != null) {
				// ConversionService not tried before, probably custom editor found
				// but editor couldn't produce the required type...
				TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);
				if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {
					return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);
				}
			}

			// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException
			StringBuilder msg = new StringBuilder();
			msg.append("Cannot convert value of type '").append(ClassUtils.getDescriptiveType(newValue));
			msg.append("' to required type '").append(ClassUtils.getQualifiedName(requiredType)).append("'");
			if (propertyName != null) {
				msg.append(" for property '").append(propertyName).append("'");
			}
			if (editor != null) {
				msg.append(": PropertyEditor [").append(editor.getClass().getName()).append(
						"] returned inappropriate value of type '").append(
						ClassUtils.getDescriptiveType(convertedValue)).append("'");
				throw new IllegalArgumentException(msg.toString());
			}
			else {
				msg.append(": no matching editors or conversion strategy found");
				throw new IllegalStateException(msg.toString());
			}
		}
	}

	if (conversionAttemptEx != null) {
		if (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) {
			throw conversionAttemptEx;
		}
		logger.debug("Original ConversionService attempt failed - ignored since " +
				"PropertyEditor based conversion eventually succeeded", conversionAttemptEx);
	}
	// 
	return (T) convertedValue;
}
```
